\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}

\newcommand{\progname}{Program Name}

\begin{document}

\title{Module Interface Specification for ...}

\author{Author Name}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
3D Cartesian Coordinate & Point3D &  A 3-dimensional cartesian coordinate, 
represented as an (x,y,z)-tuple where all three are $\mathbb{R}$ values\\
RGB Colour & Colour &  A 3-tuple represented as (r,g,b)- where all three are 
$\mathbb{R}$ values\\
Shape of Object & Shape & The abstract shape that an object mesh is classified 
as. It can be one of the following : sphere, cube, torus, teapot. \\
Polygon Mesh & Mesh & Mesh constructed of vertices, edges, and traingle 
surfaces to create one of the allowed shapes.\\
Normal Map of Object & nMap & A structure maintaining a list of the normal 
vectors for the measured points on the mesh. \\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & ~ \\
		\midrule
		
		\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Input Parameters 
		Module\\
		%%Purpose of the input parameters module is to parse the JSON file and 
		%%separate 
		%%it into usable objects
		& Output Format Module \\
		%% Purpose is to create the output of the module
		& Shape Module\\
		& Colour Module\\
		& 3D Cartesian Coordinate Module\\ %%Data type for representing 
		%%cartesian 
		%%coordinates; works with the vector math module to define vectors and 
		%%calculate 
		%%things
		& Polygon Mesh Module\\ %I'm not reinventing the wheel with this 
		%module; people 
		%smarter than me have implemented polygon mesh libraries and data 
		%structures.
		& Normal Maps Module\\ %I'm not reinventing the wheel with this module; 
		%people 
		%smarter than me have implemented vector calculus.
		& Scene Module\\
		%% Data type definition of a scene in this program
		& Object Module\\
		%% Data type definition of an object in this program
		& Light Source Module\\
		%% Data type definition of a light source in this program
		& Observer Module \\
		%% Data type definition of an observer in this program
		& Vector Math Module\\ %I'm not reinventing the wheel with this module; 
		%people 
		%smarter than me have implemented vector calculus.
		& Shader Module\\
		& Lighting Model Module\\
		\midrule
		\multirow{2}{0.3\textwidth}{Software Decision Module} 
		& JSON Module\\ %I need the JSON module to parse and write JSON files
		& Rendering Module\\ %Rationale: The outputted JSON file will be passed 
		%back to 
		%unity for rendering
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

~\newpage



\section{MIS of Input Parameters Module} \ref{mInputs} \\
The Input Parameters Module converts the JSON data from the input file into the 
objects usable by the system. During this process, the input parameters 

\subsection{Module}
Input Parameters

\subsection{Uses}
JSON, Object, Light Source, Observer, Scene

\subsection{Syntax}
\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{*}{convertJSONtoScene} & \multirow{4}{2cm}{JSON File} & s: 
		Scene & INPUT\_INVALID\_FILE\\
		& & o : Object & INPUT\_FILE\_EMPTY\\
		& & l : LightSource & \\
		& & v : Observer & \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
\noindent convertJSONtoScene($in: JSON$):
\begin{itemize}
	\item output: $s : Scene, o : Object, l : LightSource , v: Observer | 
	s.Valid(o,l,v)$ %%The scene will check whether the positional information 
	%%is valid.
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage


%% -----------------------------Basic Types---------------------------------
\section{MIS of Point3D} \ref{mPoints} \\
The Point3D module captures the structure of a 3D Caretsian Coordinate and 
functions that are useful for this structure.

\subsection{Template Module}
Point3D

\subsection{Uses} -

\subsection{Syntax}
\subsubsection{Exported Types}
Point3D = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Point & $\mathbb{R}, \mathbb{R}, \mathbb{R}$ & -- & -- \\
		.x & -- & $\mathbb{R}$ & -- \\
		.y & -- & $\mathbb{R}$ & -- \\		
		.z & -- & $\mathbb{R}$ & -- \\
		distance\_abs & Point3D & $\mathbb{R}$ & -- \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
x : $\mathbb{R}$ \\
y : $\mathbb{R}$ \\
z : $\mathbb{R}$ \\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
Point3D positions (x,y,z) are only set once (at initialization). This means 
there will be no individual setter methods.

We assume that all the routines can only be called after Point() has been 
called once. This means there needs to be at least one Point3D before you can 
call other routines.

\subsubsection{Access Routine Semantics}
\noindent Point($Ix: \mathbb{R}, Iy: \mathbb{R}, Iz: \mathbb{R}$):
\begin{itemize}
	\item transition: $x, y, z := Ix, Iy, Iz$
	\item exception: N/A
\end{itemize}

\noindent .x():
\begin{itemize}
	\item output: $self.x$
	\item exception: N/A
\end{itemize}

\noindent .y():
\begin{itemize}
	\item output: $self.y$
	\item exception: N/A
\end{itemize}

\noindent .z():
\begin{itemize}
	\item output: $self.z$
	\item exception: N/A
\end{itemize} 

\noindent distance\_abs(p:Point3D):
\begin{itemize}
	\item output: $ \sqrt{(p.x-self.x)^2 + (p.y-self.y)^2 + (p.z-self.z)^2}$
	\item exception: N/A
\end{itemize} 

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Colour} \ref{mColour} \\
The Colour module captures the structure of colours used in this program.

\subsection{Template Module}
Colour

\subsection{Uses} -

\subsection{Syntax}
\subsubsection{Exported Types}
Colour = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Colour & $\mathbb{Z}^+,\mathbb{Z}^+,\mathbb{Z}^+$ & -- & 
		-- \\
		.r & -- & $\mathbb{Z}^+$ & -- \\
		.g & -- & $\mathbb{Z}^+$ & -- \\		
		.b & -- & $\mathbb{Z}^+$ & -- \\		%%
		.set\_r & $\mathbb{Z}^+$ & & -- \\
		.set\_g & $\mathbb{Z}^+$ & & -- \\		
		.set\_b & $\mathbb{Z}^+$ & & -- \\		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
r : $\mathbb{Z}^+$ \\
g : $\mathbb{Z}^+$ \\
b : $\mathbb{Z}^+$ \\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\begin{itemize}
	\item Colours can be changed at any point in time - therefore setters will 
	be needed.
	\item Colours are represented by RGB values that (individually) range from 
	0 to 255.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent Colour($Ir: \mathbb{Z}^+, Ig: \mathbb{Z}^+, Ib: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: $r, g, b := Ir, Ig, Ib$
	\item exception: exc := $(r < 0 || r > 255) \implies $INVALID\_R \\
		$ | (g < 0 || g > 255) \implies $INVALID\_G \\ $| (b < 0 || b > 255) 
		\implies $INVALID\_B
\end{itemize}

\noindent .r():
\begin{itemize}
	\item output: $self.r$
	\item exception: N/A
\end{itemize}

\noindent .g():
\begin{itemize}
	\item output: $self.g$
	\item exception: N/A
\end{itemize}

\noindent .b():
\begin{itemize}
	\item output: $self.b$
	\item exception: N/A
\end{itemize} 

\noindent .set\_r($Ir: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: r := Ir
	\item exception: exc := $(r < 0 || r > 255) \implies $INVALID\_R \\
\end{itemize}

\noindent .set\_g($Ig: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: g := Ig
	\item exception: exc := $(g < 0 || g > 255) \implies $INVALID\_G \\
\end{itemize}

\noindent .set\_b($Ib: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: b := Ib
	\item exception: exc := $(b < 0 || b > 255) \implies $INVALID\_B \\
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Vector} \ref{mVector} \\
The Vector module captures the structure of Vector objects.

\subsection{Template Module}
Vector

\subsection{Uses}
Point3D \ref{mPoints}

\subsection{Syntax}
\subsubsection{Exported Types}
Vector = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Vector\_P & Point3D, Point3D & -- & -- \\
		Vector & $ \mathbb{Z},\mathbb{Z},\mathbb{Z},\mathbb{R} $ & -- & -- \\
		.m & & $\mathbb{R}$ & -- \\
		direction & & $ \mathbb{Z},\mathbb{Z},\mathbb{Z}$  & -- 
		\\	
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
start := Point3D \\
ux := $\mathbb{Z}$ \\
uy := $\mathbb{Z}$ \\
uz := $\mathbb{Z}$ \\
m := $\mathbb{R}$ \\ 

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\begin{itemize}
	\item Vectors can be created infinitely; we will only set them once during 
	initialization.			
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent Vector(p:Point3D, q:Point3D):
\begin{itemize}
	\item transition: start:= p\\
	$ux:= (q.x - p.x)/m$ \\
	$uy:= (q.y - p.y)/m$ \\
	$uz:= (q.z - p.z)/m$ \\
	$m := start.distance\_abs(q)$\\
	\item exception: --
\end{itemize}

\noindent Vector($Ix: \mathbb{Z}, Iy: \mathbb{Z}, Iz: \mathbb{Z}, Im: 
\mathbb{R} 
$):
\begin{itemize}
	\item transition: ux, uy, uz, m := Ix, Iy, Iz, Im
	\item exception: exc := $(ux < -1 || ux > 1) \implies $INVALID\_UX \\
	$ | (ux < -1 || ux > 1) \implies$  INVALID\_UY \\ $| $(ux $< -1 ||$ ux $> 
	1$) $\implies $ INVALID\_UZ \\ $| (m < 0) \implies$ INVALID\_M
\end{itemize}

\noindent .m():
\begin{itemize}
	\item output: $self.m$
	\item exception: N/A
\end{itemize}

\noindent direction():
\begin{itemize}
	\item output: $self.ux, self.uy, self.uz$
	\item exception: N/A
\end{itemize}

\noindent .start():
\begin{itemize}
	\item output: $self.start$
	\item exception: N/A
\end{itemize}


\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Light Type} \ref{mLightType} \\
The Light Type module is an abstract data type which captures information 
related to the different types of light sources.

\subsection{Template Module}
LightType

\subsection{Uses}
N/A

\subsection{Syntax}
\subsubsection{Exported Types}
LightType = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		LightType & \{ambient,point,spotlight,directional\} & LightType & -- \\
		.name & & LightType & -- \\
		.i & LightType & $\mathbb{R},\mathbb{R} \to 
		\mathbb{R}$ & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
name := \{ ambient, point, spotlight, directional \} \\
i := Function that describes how the light intensity changes as a function of 
distance. Every type of light has an associated function - so this should 
really be a set of functions.\\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent LightType(inName):
\begin{itemize}
	\item transition: self.name := inName \\
					  self.i := (name == ambient $\implies \lambda d, i_{0} \to 
					  i_{0}$ |\\
					  name == directional $\implies \lambda d, i_{0} \to 
					  \frac{1}{d^2}i_{0}$)
	\item output: self
	\item exception: exc:= \{inName $\notin$ {ambient, spotlight, point, 
	directional} $\implies$ INVALID\_LIGHT\_TYPE \}
\end{itemize}

\noindent .name():
\begin{itemize}
	\item output: $self.name$
	\item exception: N/A
\end{itemize}

\noindent .i():
\begin{itemize}
	\item output: $self.i$
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Polygon} \ref{mPolygon} \\
The Polygon module is an abstract data type captures the structure of polygons 
used in polygon meshes.

\subsection{Template Module}
Polygon

\subsection{Uses}
Point3d \ref{mPoints} \\
Vector \ref{mVector}\\

\subsection{Syntax}
\subsubsection{Exported Types}
Polygon = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Polygon & \{triangle, quad\}, (Point3D, Vector)$^n$ & -- & -- \\
		.shape & -- & \{triangle, quad\} & -- \\
		.bounds & -- & Set of (Point3D, Vector) & -- \\
		.s\_norm & -- & Vector & -- \\
		getEdges & Point3D & Set of Vectors & -- \\
		getPoints & & Set of Point3D & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
shape := \{triangle, quad\}
bounds := Set of (Point3D, Vector) tuples
s\_norm := Vector

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent Polygon($t:\{triangle, quad\}, (p:Point3D, v:Vector)^n$):
\begin{itemize}
	\item transition:= $shape := t;$ \\
	$bounds := \cup (p,v)$ \\
	s\_norm := Calculate norm as cross-product of two vectors from 1 vertex.
	\item exception: exc := \{(t $\notin$ \{triangle, quad\} $\implies$ 
	INVALID\_SHAPE) \\ $|$ (t:\{triangle, quad\},b: Set of (Point3D, Vector)$|$ 
	t == triangle, sizeOfBounds $<$ 6 $\implies$ TOO\_FEW\_POINTS) \\ $|$ 
	(t:\{triangle, quad\},b: Set of (Point3D, Vector) $|$ t == triangle, 
	sizeOfBounds $>$ 6 $\implies$ TOO\_MANY\_POINTS) \\ $|$ 
	(t:\{triangle, quad\},b: Set of (Point3D, Vector) $|$ t == quad, 
	sizeOfBounds $>$ 8 $\implies$ TOO\_MANY\_POINTS) \\ $|$ 
	(t:\{triangle, quad\},b: Set of (Point3D, Vector) $|$ t == quad, 
	sizeOfBounds $<$ 8 $\implies$ TOO\_FEW\_POINTS)  \}\\
\end{itemize}

\noindent .shape():
\begin{itemize}
	\item output:= self.shape
	\item exception: N/A
\end{itemize}

\noindent .bounds():
\begin{itemize}
	\item output:= self.bounds
	\item exception: N/A
\end{itemize}

\noindent .s\_norm():
\begin{itemize}
	\item output:= self.s\_norm
	\item exception: N/A
\end{itemize}

\noindent getEdges(p:Point3D):
This method retrieves all the edges that are connected to the vertex 
represented by Point3D p. Individual polygons should have a maximum of two 
edges per vertex based on the polygon assumptions.
\begin{itemize}
	\item output:= Set of Vectors := $\forall b : (Point3D,Vector) | (b \in 
	self.bounds \wedge b[0] == p) \implies \cup b[1] $
	\item exception: N/A
\end{itemize}

\noindent getPoints():
This method retrieves the set of points in the polygon.
\begin{itemize}
	\item output: Set of Point3D := $b: (Point3D, Vector)| \forall b \in 
	self.bounds  \cup b.[0]$
	\item exception: N/A
\end{itemize}


\subsubsection{Local Functions}
sizeOfBounds $\equiv$ Number of elements in the set of (Point3D, Vector) 
tuples.\\

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

%%---------------------------------Complex Types--------------------------------
%%These are just the types that rely on the beasic types but are closer in 
%%detail to the problem we're trying to describe.

\section{MIS of Mesh} \ref{mMesh} \\
The Mesh module is an abstract data type that captures the structure of polygon 
meshes as used by this program. It also provides methods to find out basic data 
about the polygon mesh.

\subsection{Template Module}
Mesh

\subsection{Uses}
Point3d \ref{mPoints} \\
Vector \ref{mVector}\\
VecMath \ref{mVecMath}\\
Polygon \ref{mPolygon}\\

\subsection{Syntax}
\subsubsection{Exported Types}
Mesh = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Mesh & Set of Polygons & -- & -- \\
		.Surfaces & - & Set of Polygons & -- \\
		.Edges & - & Set of Vectors & -- \\
		.Vertices & - & Set of Point3D & -- \\
		isInMesh & Polygon & $\mathbb{B}$ & -- \\ %Check whether the given 
		%polygon is part of the mesh
		numPoly & Point3D & $\mathbb{Z^+}$ & -- \\ %Given a vertex, count how 
		%many polygons that vertex is attached to.
		intersects & Vector & Polygon & -- \\ %Given a vector (e.g. a ray) 
		%calculate the polygon that it intersects with in that mesh
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
Vertices : Set of Point3D\\
Edges : Set of Vectors\\
Surfaces : Set of Polygons\\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent Mesh($P:Set of Polygons$):
\begin{itemize}
	\item transition: Surfaces := P \\
	Vertices := $(p:Polygon | \forall p \in P \to \cup p.getPoints)$\\
	(Vertices pulls its values from the bounds of the polygons in P)\\
	Edges := $(p:Polygon, v:Point3D | \forall p \in P \forall v \in p.getPoints 
	\cup (p.getEdges(v)))$\\
	(Edges pulls its values from the bounds of the polygons in P)\\
	\item exception: exc := \{ P == $\emptyset \implies$ INVALID\_MESH\\ $| 
	(p,q:Polygon| \forall p, q \in P, p \neq q \land p.shape \neq q.shape 
	\implies$ POLYGON\_SHAPES\_MISMATCH)\\ $| (p,q:Polygon, 
	p_{1},q_{1}:Point3D| 
	\forall p \in P, \exists q \in P$ such that $\exists p_{1} \in 
	p.getPoints() 
	\land \exists q_{1} \in q.getPoints()$ such that $p_{1} \neq q_{1} 
	\implies$ 
	INVALID\_POLYS)\}\\
	
\end{itemize}

\noindent .Surfaces():
\begin{itemize}
	\item output := self.Surfaces \\
	\item exception: N/A\\
\end{itemize}

\noindent .Vertices():
\begin{itemize}
	\item output := self.Vertices \\
	\item exception: N/A\\
\end{itemize}

\noindent .Edges():
\begin{itemize}
	\item output := self.Edges \\
	\item exception: N/A\\
\end{itemize}

\noindent isInMesh($p:Polygon$):
\begin{itemize}
	\item output := $(q:Polygon|\exists q \in self.Surfaces where q == p)$ \\
	\item exception: N/A\\
\end{itemize}

\noindent numPoly($p:Point3D$):
\begin{itemize}
	\item output:=  counter := $p \in$ self.Vertices $\implies (s:Polygon| 
	\forall s \in$ self.Surfaces) if $p \in s.bounds$ then $counter++$ \\
	\item exception: exc := $\{p \notin self.Vertices \implies$ 
	ERR\_POINT\_NOT\_IN\_MESH\}\\
\end{itemize}

\noindent intersects($r:Vector$):
\begin{itemize}
	\item output := calculate whether the given vector intersects with any 
	polygon on the mesh, and return the first polygon it intersects with.\\
	\item exception: exc := \\
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Mesh} \ref{mLightSource} \\
The Light Source module is an Abstract Data Type that defines the structure and 
behaviours of light sources in the scene.
\subsection{Template Module}
LightSource

\subsection{Uses}
Point3d \ref{mPoints} \\
Vector \ref{mVector}\\
VecMath \ref{mVecMath}\\
Polygon \ref{mPolygon}\\

\subsection{Syntax}
\subsubsection{Exported Types}
LightSource = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		LightSource & Point3D, Colour, LightType, $\mathbb{R}$ Set of Vectors & 
		LightSource & \\
		.origin & & Point3D & \\
		.colour & & Colour & \\
		.type & & LightType & \\
		.intensity & & $\mathbb{R}$ & \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
o: Point3D \\ %%Origin position of light source
c: Colour \\
t: lightType \\
$i_{0}$: $\mathbb{R}$ \\
ds: Set of Vector \\ %%Set of direction vectors 

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}

\noindent LightSource(inP: Point3d, inC: Colour, lt: LightType, ins: 
$\mathbb{R}$ inDs: Set of Vectors):
\begin{itemize}
	\item transition: o, c, t, i, ds := inP, inC, lt, ins, inDs \\
	\item exception: N/A\\
\end{itemize}

\noindent .origin():
\begin{itemize}
	\item output:= self.o\\
	\item exception: N/A\\
\end{itemize}

\noindent .colour():
\begin{itemize}
	\item output:= self.c\\
	\item exception: N/A\\
\end{itemize}

\noindent .type():
\begin{itemize}
	\item output:= self.t\\
	\item exception: N/A\\
\end{itemize}

\noindent .intensity():
\begin{itemize}
	\item output: self.i\\
	\item exception: N/A\\
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage


%%---------------------------------Libraries------------------------------------
\section{MIS of VecMath} \ref{mVecMath} \\
The Vector Math module is a library of services that can be used with Vectors. 
All functions here take in 2 Vectors and output either a Vector or a scalar 
value.

\subsection{Module}
VecMath

\subsection{Uses}
Vector \ref{mVector}\\

\subsection{Syntax}
\subsubsection{Exported Constants}
N/A
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		add & Vector $\times$ Vector & Vector & -- \\
		sclMult & Vector $\times \mathbb{R}$ & Vector & -- \\ 
		dot & Vector $\times$ Vector & $\mathbb{R}$ & -- \\
		cross & Vector $\times$ Vector & Vector & -- \\
		angleBetween & Vector $\times$ Vector & rad & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent add($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: 
	Vector((v1.x+v2.x),(v1.y+v2.y),(v1.z,v2.z), \\
	$\sqrt{(v1.x+v2.x)^2+(v1.y+v2.y)^2+(v1.z,v2.z)^2}$)
	\item exception: exc := \\
\end{itemize}

\noindent sclMult($v1:Vector, r:\mathbb{R}$):
\begin{itemize}
	\item output: 
	ux := $r \times v1.x$ \\
	uy := $r \times v1.y$ \\
	uz := $r \times v1.z$ \\	
	\item exception: \\
\end{itemize}


\noindent dot($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: 
	ux := $v1.x \times v2.x$ \\
	uy := $v1.y \times v2.y$ \\
	uz := $v1.z \times v2.z$ \\
	\item exception: \\
\end{itemize}

\noindent cross($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: 
	ux := $(v1.y \times v2.z) - (v1.z \times v2.y)$  \\
	uy := $(v1.z \times v2.x) - (v1.x \times v2.z)$  \\
	uz := $(v1.x \times v2.y) - (v1.y \times v2.x)$  \\
	\item exception: \\
\end{itemize}

\noindent angleBetween($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: $\cos^{-1}(\frac{dot(v1, v2)}{v1.m \times v2.m})$
	\item exception: \\
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Scene Module} \ref{mScene} \\
The Scene Module is an abstract object module that contains the structure for 
the overall scene. It maintains information about the entities in the scene 
(object, light source, observer) regarding their distances between each other. 
It constrains the positions, sizes, and directions of entities based on the 
specified size of the scene.
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Scene

\subsection{Uses}
Input,  

\subsection{Syntax}
\subsubsection{Exported Constants}
$SCENE\_MAX\_X : \mathbb{R}$\\
$SCENE\_MIN\_X : \mathbb{R}$\\
$SCENE\_MAX\_Y : \mathbb{R}$\\
$SCENE\_MIN\_Y : \mathbb{R}$\\
$SCENE\_MAX\_Z : \mathbb{R}$\\
$SCENE\_MIN\_Z : \mathbb{R}$\\
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		initScene & $max\_X : \mathbb{R}$ & & \\
		 & $max\_Y : \mathbb{R}$ & & \\		
		 & $max\_Z : \mathbb{R}$ & & \\				 
		 & $o : Object$ & & \\				 
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes 
%appropriate.}

\subsubsection{Access Routine Semantics}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage


\section{MIS of Objects Module} \label{mObjects} 
The Objects Module is an abstract object module that contains the structure for 
objects to be lit. This includes fields and methods associated with these 
objects. This module will not be accessed by the user; it will be used 
extensively by other modules in the system to find data about the objects in 
the scene, and to manipulate their data.
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Objects

\subsection{Uses}
Input,  
 
\subsection{Syntax}
\subsubsection{Exported Constants}
$SCENE\_MAX\_X : \mathbb{R}$\\
$SCENE\_MIN\_X : \mathbb{R}$\\
$SCENE\_MAX\_Y : \mathbb{R}$\\
$SCENE\_MIN\_Y : \mathbb{R}$\\
$SCENE\_MAX\_Z : \mathbb{R}$\\
$SCENE\_MIN\_Z : \mathbb{R}$\\
\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\multirow{11}{*}{InitObj} & $type: Shape,$ & & \\
& $ mesh: Mesh,$ & & \\
& $position : Point3D,$ & & \\
& $size : \mathbb{Z},$ & & \\  
& $base : Colour,$ & & \\
& $spec : Colour,$ & & \\
& $kd : \mathbb{Z},$ & & \\
& $ka : \mathbb{Z},$ & & \\
& $ks : \mathbb{Z},$ & & \\
& $alpha : \mathbb{N},$ & & \\
& $nmap : NMap $ & & \\
%%Getters
GetObj\_Type & - & Shape & - \\
GetObj\_Mesh & - & Mesh & - \\
GetObj\_Position & - & Point3D & - \\
GetObj\_Size &- & $\mathbb{Z}$ & \\
GetObj\_BaseColour &- & Colour & \\
GetObj\_SpecColour &- & Colour & \\
GetObj\_kd &- & $\mathbb{Z}$ & \\
GetObj\_ka &- & $\mathbb{Z}$& \\
GetObj\_ks &- & $\mathbb{Z}$ & \\
GetObj\_alpha &- & $\mathbb{N}$ & \\
GetObj\_NormalMap &- & $nMap$& \\ 
%%Setters
SetObj\_Position & Point3D & - & \\
SetObj\_Size & $\mathbb{Z}$ & - & \\
SetObj\_BaseColour & Colour &- & \\
SetObj\_SpecColour & Colour &- & \\
SetObj\_kd & $\mathbb{Z}$ &- & IV\_OUT\_OF\_BOUNDS\\
SetObj\_ka & $\mathbb{Z}$&- & IV\_OUT\_OF\_BOUNDS\\
SetObj\_ks & $\mathbb{Z}$ &- & IV\_OUT\_OF\_BOUNDS\\
SetObj\_alpha & $\mathbb{Z}$ &- & IV\_OUT\_OF\_BOUNDS\\
SetObj\_NormalMap & $nMap$ &- &- \\
%%
\hline
\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes 
%appropriate.}

\subsubsection{Access Routine Semantics}
\noindent InitObj($type: Shape, mesh: Mesh, position : Point3D, size : 
\mathbb{Z},  
base : Colour, spec : Colour, kd : \mathbb{Z}, ka : \mathbb{Z}, ks : 
\mathbb{Z}, alpha : \mathbb{N}, nmap : NMap $):
\begin{itemize}
	\item transition: New object created with these properties. 
	\item exception: N/A
\end{itemize}

\noindent GetObj\_Type():
\begin{itemize}
%\item transition: \wss{if appropriate} 
\item output: $s : Shape$. The shape of the object.
\item exception: N/A
\end{itemize}

\noindent GetObj\_Mesh():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $m : Mesh$. The mesh of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_Position():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $centre_point : Point3D$. The centre point of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_Size():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $size : \mathbb{Z}$. The size of the object; this is the 
	value that scales the polygon mesh up or down from the base model.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_BaseColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $b : Colour$. The base colour of the object. This is the 
	colour that would come through if the object is not specular or diffuse.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_SpecColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $spec : Colour$. The specular colour of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_kd():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $kd : \mathbb{Z}$. The diffuse coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_ka():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $ka : \mathbb{Z}$. The ambient coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_ks():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $ks : \mathbb{Z}$. The specular coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_alpha():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $a : \mathbb{Z}$. The shininess coefficient of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_NormalMap():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: A normal map of the object. This is a list of normals based 
	on shader calculations, and a string literal that describes the type of 
	normals (vertex, surface, pixel).
	\item exception: N/A
\end{itemize}
%%Setters
\noindent SetObj\_Type(Colour (r,g,b)):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: --
	\item exception: $err := $\\
	 $Colour.r > 255 \implies IV\_OUT\_OF\_BOUNDS$ \\
	 | \\
	 $Colour.g > 255 \implies IV\_OUT\_OF\_BOUNDS$ \\
	 | \\
	 $Colour.b > 255 \implies IV\_OUT\_OF\_BOUNDS$	\\
	 | \\
	 $Colour.r < 1 \implies IV\_OUT\_OF\_BOUNDS$ \\
	 | \\
	 $Colour.g < 1 \implies IV\_OUT\_OF\_BOUNDS$ \\
	 | \\
	 $Colour.b < 1 \implies IV\_OUT\_OF\_BOUNDS$	\\	 
\end{itemize}

\noindent SetObj\_Position(Point3D (x,y,z)):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: -
	\item exception: N/A
\end{itemize}

\noindent GetObj\_Size():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $size : \mathbb{Z}$. The size of the object; this is the 
	value that scales the polygon mesh up or down from the base model.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_BaseColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $b : Colour$. The base colour of the object. This is the 
	colour that would come through if the object is not specular or diffuse.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_SpecColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $spec : Colour$. The specular colour of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_kd():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $kd : \mathbb{Z}$. The diffuse coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_ka():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $ka : \mathbb{Z}$. The ambient coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_ks():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $ks : \mathbb{Z}$. The specular coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_alpha():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $a : \mathbb{Z}$. The shininess coefficient of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_NormalMap():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: A normal map of the object. This is a list of normals based 
	on shader calculations, and a string literal that describes the type of 
	normals (vertex, surface, pixel).
	\item exception: N/A
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Light Source Module} \label{mLights} 
The Light Source Module is an abstract object module that contains the 
structure for light sources in a scene. This includes fields and methods 
associated with these light sources. This module will not be accessed by the 
user; it will be used extensively by other modules in the system to find data 
about the lights in the scene, and to manipulate their data.
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Objects

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		%%Initialize
		InitLight & $type: Light, position : Point3D, base : Colour, intensity 
		: \mathbb{R}$  & & \\
		%%Getters
		GetLight\_Type & - & Light & - \\
		GetLight\_Position & - & Point3D & - \\
		GetLight\_BaseColour &- & Colour & \\
		GetLight\_BaseIntensity & - & $\mathbb{R}$& \\
		%%Setters
%%		SetLight\_Position & Point3D & - & \\ %%Based on assumptions from CA 
%%%%lights can't change position when the program is running.
		SetLight\_BaseColour & Colour &- & \\
		SetLight\_BaseIntensity & $\mathbb{R}$ & - & \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes 
%appropriate.}

\subsubsection{Access Routine Semantics}

\noindent InitLight($type: Light, position : Point3D, base : Colour, intensity 
: \mathbb{R}$):
\begin{itemize}
	\item transition: Create a new light source in the scene with these 
	properties.
	\item exception: N/A
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\section{MIS of Observer Module} \label{mObsv} 
The Observer Module is an abstract object module that contains the 
structure for observers in a scene. This includes fields and methods 
associated with these observers. This module will not be accessed by the 
user; it will be used extensively by other modules in the system to find data 
about the observers in the scene, and to manipulate their data.
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Objects

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		%%Initialize
		InitObsv & $position : Point3D, direction : Vec3$  & & \\
		%%Getters
		GetObsv\_Direction & - & Vec3 & - \\
		GetObsv\_Position & - & Point3D & - \\
		%%Setters
		SetObsv\_Direction & - & Vec3 & - \\
		SetObsv\_Position & - & Point3D & - \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes 
%appropriate.}

\subsubsection{Access Routine Semantics}

\noindent InitObsv($position : Point3D, direction: Vec3$):
\begin{itemize}
	\item transition: Create a new observer in the scene with these 
	properties.
	\item exception: N/A
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of anosther module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage


\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}