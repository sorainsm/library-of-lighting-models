\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}

\newcommand{\progname}{Program Name}

\begin{document}

\title{Module Interface Specification for ...}

\author{Author Name}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
3D Cartesian Coordinate & Point3D &  A 3-dimensional cartesian coordinate, 
represented as an (x,y,z)-tuple where all three are $\mathbb{R}$ values\\
RGB Colour & Colour &  A 3-tuple represented as (r,g,b)- where all three are 
$\mathbb{R}$ values\\
Shape of Object & Shape & The abstract shape that an object mesh is classified 
as. It can be one of the following : sphere, cube, torus, teapot. \\
Polygon Mesh & Mesh & Mesh constructed of vertices, edges, and traingle 
surfaces to create one of the allowed shapes.\\
Normal Map of Object & nMap & A structure maintaining a list of the normal 
vectors for the measured points on the mesh. \\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & ~ \\
		\midrule
		
		\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Input Parameters 
		Module\\
		%%Purpose of the input parameters module is to parse the JSON file and 
		%%separate 
		%%it into usable objects
		& Output Format Module \\
		%% Purpose is to create the output of the module
		& Shape Module\\
		& Colour Module\\
		& 3D Cartesian Coordinate Module\\ %%Data type for representing 
		%%cartesian 
		%%coordinates; works with the vector math module to define vectors and 
		%%calculate 
		%%things
		& Polygon Mesh Module\\ %I'm not reinventing the wheel with this 
		%module; people 
		%smarter than me have implemented polygon mesh libraries and data 
		%structures.
		& Normal Maps Module\\ %I'm not reinventing the wheel with this module; 
		%people 
		%smarter than me have implemented vector calculus.
		& Scene Module\\
		%% Data type definition of a scene in this program
		& Object Module\\
		%% Data type definition of an object in this program
		& Light Source Module\\
		%% Data type definition of a light source in this program
		& Observer Module \\
		%% Data type definition of an observer in this program
		& Vector Math Module\\ %I'm not reinventing the wheel with this module; 
		%people 
		%smarter than me have implemented vector calculus.
		& Shader Module\\
		& Lighting Model Module\\
		\midrule
		\multirow{2}{0.3\textwidth}{Software Decision Module} 
		& JSON Module\\ %I need the JSON module to parse and write JSON files
		& Rendering Module\\ %Rationale: The outputted JSON file will be passed 
		%back to 
		%unity for rendering
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

~\newpage



\section{MIS of Input Parameters Module} \ref{mInputs} \\
The Input Parameters Module converts the JSON data from the input file into the 
objects usable by the system. During this process, the input parameters 

\subsection{Module}
Input Parameters

\subsection{Uses}
JSON, Object, Light Source, Observer, Scene

\subsection{Syntax}
\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{*}{convertJSONtoScene} & \multirow{4}{2cm}{JSON File} & s: 
		Scene & INPUT\_INVALID\_FILE\\
		& & o : Object & INPUT\_FILE\_EMPTY\\
		& & l : LightSource & \\
		& & v : Observer & \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
\noindent convertJSONtoScene($in: JSON$):
\begin{itemize}
	\item output: $s : Scene, o : Object, l : LightSource , v: Observer | 
	s.Valid(o,l,v)$ %%The scene will check whether the positional information 
	%%is valid.
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Scene Module} \ref{mScene} \\
The Scene Module is an abstract object module that contains the structure for 
the overall scene. It maintains information about the entities in the scene 
(object, light source, observer) regarding their distances between each other. 
It constrains the positions, sizes, and directions of entities based on the 
specified size of the scene.
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Scene

\subsection{Uses}
Input,  

\subsection{Syntax}
\subsubsection{Exported Constants}
$SCENE\_MAX\_X : \mathbb{R}$\\
$SCENE\_MIN\_X : \mathbb{R}$\\
$SCENE\_MAX\_Y : \mathbb{R}$\\
$SCENE\_MIN\_Y : \mathbb{R}$\\
$SCENE\_MAX\_Z : \mathbb{R}$\\
$SCENE\_MIN\_Z : \mathbb{R}$\\
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		initScene & $max\_X : \mathbb{R}$ & & \\
		 & $max\_Y : \mathbb{R}$ & & \\		
		 & $max\_Z : \mathbb{R}$ & & \\				 
		 & $o : Object$ & & \\				 
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes 
%appropriate.}

\subsubsection{Access Routine Semantics}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage


\section{MIS of Objects Module} \label{mObjects} 
The Objects Module is an abstract object module that contains the structure for 
objects to be lit. This includes fields and methods associated with these 
objects. This module will not be accessed by the user; it will be used 
extensively by other modules in the system to find data about the objects in 
the scene, and to manipulate their data.
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Objects

\subsection{Uses}
Input,  
 
\subsection{Syntax}
\subsubsection{Exported Constants}
$SCENE\_MAX\_X : \mathbb{R}$\\
$SCENE\_MIN\_X : \mathbb{R}$\\
$SCENE\_MAX\_Y : \mathbb{R}$\\
$SCENE\_MIN\_Y : \mathbb{R}$\\
$SCENE\_MAX\_Z : \mathbb{R}$\\
$SCENE\_MIN\_Z : \mathbb{R}$\\
\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline

\multirow{11}{*}{InitObj} & $type: Shape,$ & & \\
& $ mesh: Mesh,$ & & \\
& $position : Point3D,$ & & \\
& $size : \mathbb{Z},$ & & \\  
& $base : Colour,$ & & \\
& $spec : Colour,$ & & \\
& $kd : \mathbb{Z},$ & & \\
& $ka : \mathbb{Z},$ & & \\
& $ks : \mathbb{Z},$ & & \\
& $alpha : \mathbb{N},$ & & \\
& $nmap : NMap $ & & \\
%%Getters
GetObj\_Type & - & Shape & - \\
GetObj\_Mesh & - & Mesh & - \\
GetObj\_Position & - & Point3D & - \\
GetObj\_Size &- & $\mathbb{Z}$ & \\
GetObj\_BaseColour &- & Colour & \\
GetObj\_SpecColour &- & Colour & \\
GetObj\_kd &- & $\mathbb{Z}$ & \\
GetObj\_ka &- & $\mathbb{Z}$& \\
GetObj\_ks &- & $\mathbb{Z}$ & \\
GetObj\_alpha &- & $\mathbb{N}$ & \\
GetObj\_NormalMap &- & $nMap$& \\ 
%%Setters
SetObj\_Position & Point3D & - & \\
SetObj\_Size & $\mathbb{Z}$ & - & \\
SetObj\_BaseColour & Colour &- & \\
SetObj\_SpecColour & Colour &- & \\
SetObj\_kd & $\mathbb{Z}$ &- & IV\_OUT\_OF\_BOUNDS\\
SetObj\_ka & $\mathbb{Z}$&- & IV\_OUT\_OF\_BOUNDS\\
SetObj\_ks & $\mathbb{Z}$ &- & IV\_OUT\_OF\_BOUNDS\\
SetObj\_alpha & $\mathbb{Z}$ &- & IV\_OUT\_OF\_BOUNDS\\
SetObj\_NormalMap & $nMap$ &- &- \\
%%
\hline
\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes 
%appropriate.}

\subsubsection{Access Routine Semantics}
\noindent InitObj($type: Shape, mesh: Mesh, position : Point3D, size : 
\mathbb{Z},  
base : Colour, spec : Colour, kd : \mathbb{Z}, ka : \mathbb{Z}, ks : 
\mathbb{Z}, alpha : \mathbb{N}, nmap : NMap $):
\begin{itemize}
	\item transition: New object created with these properties. 
	\item exception: N/A
\end{itemize}

\noindent GetObj\_Type():
\begin{itemize}
%\item transition: \wss{if appropriate} 
\item output: $s : Shape$. The shape of the object.
\item exception: N/A
\end{itemize}

\noindent GetObj\_Mesh():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $m : Mesh$. The mesh of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_Position():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $centre_point : Point3D$. The centre point of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_Size():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $size : \mathbb{Z}$. The size of the object; this is the 
	value that scales the polygon mesh up or down from the base model.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_BaseColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $b : Colour$. The base colour of the object. This is the 
	colour that would come through if the object is not specular or diffuse.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_SpecColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $spec : Colour$. The specular colour of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_kd():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $kd : \mathbb{Z}$. The diffuse coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_ka():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $ka : \mathbb{Z}$. The ambient coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_ks():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $ks : \mathbb{Z}$. The specular coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_alpha():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $a : \mathbb{Z}$. The shininess coefficient of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_NormalMap():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: A normal map of the object. This is a list of normals based 
	on shader calculations, and a string literal that describes the type of 
	normals (vertex, surface, pixel).
	\item exception: N/A
\end{itemize}
%%Setters
\noindent SetObj\_Type(Colour (r,g,b)):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: --
	\item exception: $err := $\\
	 $Colour.r > 255 \implies IV\_OUT\_OF\_BOUNDS$ \\
	 | \\
	 $Colour.g > 255 \implies IV\_OUT\_OF\_BOUNDS$ \\
	 | \\
	 $Colour.b > 255 \implies IV\_OUT\_OF\_BOUNDS$	\\
	 | \\
	 $Colour.r < 1 \implies IV\_OUT\_OF\_BOUNDS$ \\
	 | \\
	 $Colour.g < 1 \implies IV\_OUT\_OF\_BOUNDS$ \\
	 | \\
	 $Colour.b < 1 \implies IV\_OUT\_OF\_BOUNDS$	\\	 
\end{itemize}

\noindent SetObj\_Position(Point3D (x,y,z)):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: -
	\item exception: N/A
\end{itemize}

\noindent GetObj\_Size():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $size : \mathbb{Z}$. The size of the object; this is the 
	value that scales the polygon mesh up or down from the base model.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_BaseColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $b : Colour$. The base colour of the object. This is the 
	colour that would come through if the object is not specular or diffuse.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_SpecColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $spec : Colour$. The specular colour of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_kd():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $kd : \mathbb{Z}$. The diffuse coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_ka():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $ka : \mathbb{Z}$. The ambient coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_ks():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $ks : \mathbb{Z}$. The specular coefficient.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_alpha():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: $a : \mathbb{Z}$. The shininess coefficient of the object.
	\item exception: N/A
\end{itemize}

\noindent GetObj\_NormalMap():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: A normal map of the object. This is a list of normals based 
	on shader calculations, and a string literal that describes the type of 
	normals (vertex, surface, pixel).
	\item exception: N/A
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Light Source Module} \label{mLights} 
The Light Source Module is an abstract object module that contains the 
structure for light sources in a scene. This includes fields and methods 
associated with these light sources. This module will not be accessed by the 
user; it will be used extensively by other modules in the system to find data 
about the lights in the scene, and to manipulate their data.
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Objects

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		%%Initialize
		InitLight & $type: Light, position : Point3D, base : Colour, intensity 
		: \mathbb{R}$  & & \\
		%%Getters
		GetLight\_Type & - & Light & - \\
		GetLight\_Position & - & Point3D & - \\
		GetLight\_BaseColour &- & Colour & \\
		GetLight\_BaseIntensity & - & $\mathbb{R}$& \\
		%%Setters
%%		SetLight\_Position & Point3D & - & \\ %%Based on assumptions from CA 
%%%%lights can't change position when the program is running.
		SetLight\_BaseColour & Colour &- & \\
		SetLight\_BaseIntensity & $\mathbb{R}$ & - & \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes 
%appropriate.}

\subsubsection{Access Routine Semantics}

\noindent InitLight($type: Light, position : Point3D, base : Colour, intensity 
: \mathbb{R}$):
\begin{itemize}
	\item transition: Create a new light source in the scene with these 
	properties.
	\item exception: N/A
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\section{MIS of Observer Module} \label{mObsv} 
The Observer Module is an abstract object module that contains the 
structure for observers in a scene. This includes fields and methods 
associated with these observers. This module will not be accessed by the 
user; it will be used extensively by other modules in the system to find data 
about the observers in the scene, and to manipulate their data.
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Objects

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		%%Initialize
		InitObsv & $position : Point3D, direction : Vec3$  & & \\
		%%Getters
		GetObsv\_Direction & - & Vec3 & - \\
		GetObsv\_Position & - & Point3D & - \\
		%%Setters
		SetObsv\_Direction & - & Vec3 & - \\
		SetObsv\_Position & - & Point3D & - \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes 
%appropriate.}

\subsubsection{Access Routine Semantics}

\noindent InitObsv($position : Point3D, direction: Vec3$):
\begin{itemize}
	\item transition: Create a new observer in the scene with these 
	properties.
	\item exception: N/A
\end{itemize}

%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of anosther module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage


\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}