\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}

\newcommand{\progname}{Program Name}

\begin{document}

\title{Module Interface Specification for ...}

\author{Author Name}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
3D Cartesian Coordinate & Point3D &  A 3-dimensional cartesian coordinate, 
represented as an (x,y,z)-tuple where all three are $\mathbb{R}$ values\\
RGB Colour & Colour &  A 3-tuple represented as (r,g,b)- where all three are 
$\mathbb{R}$ values\\
Shape of Object & Shape & The abstract shape that an object mesh is classified 
as. It can be one of the following : sphere, cube, torus, teapot. \\
Polygon Mesh & Mesh & Mesh constructed of vertices, edges, and traingle 
surfaces to create one of the allowed shapes.\\
Normal Map of Object & nMap & A structure maintaining a list of the normal 
vectors for the measured points on the mesh. \\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & ~ \\
		\midrule
		
		\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Input Parameters 
		Module\\
		%%Purpose of the input parameters module is to parse the JSON file and 
		%%separate 
		%%it into usable objects
		& Output Format Module \\
		%% Purpose is to create the output of the module
		& Polygon Module\\
		& Colour Module\\
		& 3D Cartesian Coordinate (Point3D) Module\\ %%Data type for 
		%%representing 
		%%cartesian 
		%%coordinates; works with the vector math module to define vectors and 
		%%calculate 
		%%things
		& Polygon Mesh Module\\ %I'm not reinventing the wheel with this 
		%module; people 
		%smarter than me have implemented polygon mesh libraries and data 
		%structures.
		& Normal Maps Module\\ %I'm not reinventing the wheel with this module; 
		%people 
		%smarter than me have implemented vector calculus.
		& Scene Module\\
		%% Data type definition of a scene in this program
		& Object Module\\
		%% Data type definition of an object in this program
		& Light Source Module\\
		%% Data type definition of a light source in this program
		& Observer Module \\
		%% Data type definition of an observer in this program
		& Vector Math Module\\ %I'm not reinventing the wheel with this module; 
		%people 
		%smarter than me have implemented vector calculus.
		& Shader Module\\
		& Lighting Model Module\\
		\midrule
		\multirow{2}{0.3\textwidth}{Software Decision Module} 
		& JSON Module\\ %I need the JSON module to parse and write JSON files
		& Rendering Module\\ %Rationale: The outputted JSON file will be passed 
		%back to 
		%unity for rendering
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

~\newpage

The following sections of this document will outline the module interface 
specifications for the modules listed in the module hierarchy. Two modules are 
omitted from this discussion: the hardware-hiding module, and the rendering 
module. The hardware hiding module is provided via the syntax of the 
programming language to interface with the computer hardware, as such I will 
not be documenting it here. The rendering module will be handled by the Unity 
environment, the process of documenting how it would work wouldn't be 
appropriate for the scope of this work. Suffice it to say that the 
documentation for the rendering module can be found in the documentation for 
the Unity Engine.

%% -------------------------File Related Modules--------------------------------
\section{MIS of Input Parameters Module} \ref{mInputs} \\
The Input Parameters Module converts the JSON data from the input file into the 
objects usable by the system. During this process, the input parameters 

\subsection{Module}
Input Parameters

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{*}{convertJSONtoScene} & \multirow{4}{2cm}{JSON File} & s: 
		Scene & INPUT\_INVALID\_FILE\\
		& & o : Object & INPUT\_FILE\_EMPTY\\
		& & l : LightSource & \\
		& & v : Observer & \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
%\wss{Not all modules will have state variables.  State variables give the 
%module a memory.}

\subsubsection{Environment Variables}
input: File
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
\noindent convertJSONtoScene($in: JSON$):
\begin{itemize}
	\item output: $s : Scene, o : Object, l : LightSource , v: Observer | 
	s.Valid(o,l,v)$ %%The scene will check whether the positional information 
	%%is valid.
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage


%% -----------------------------Basic Types---------------------------------
\section{MIS of Point3D} \ref{mPoints} \\
The Point3D module captures the structure of a 3D Caretsian Coordinate and 
functions that are useful for this structure.

\subsection{Template Module}
Point3D

\subsection{Uses} -

\subsection{Syntax}
\subsubsection{Exported Types}
Point3D = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Point & $\mathbb{R}, \mathbb{R}, \mathbb{R}$ & Point3D & -- \\
		.x & -- & $\mathbb{R}$ & -- \\
		.y & -- & $\mathbb{R}$ & -- \\		
		.z & -- & $\mathbb{R}$ & -- \\
		distance\_abs & Point3D & $\mathbb{R}$ & -- \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
x : $\mathbb{R}$ \\
y : $\mathbb{R}$ \\
z : $\mathbb{R}$ \\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
Point3D positions (x,y,z) are only set once (at initialization). This means 
there will be no individual setter methods.

We assume that all the routines can only be called after Point() has been 
called once. This means there needs to be at least one Point3D before you can 
call other routines.

\subsubsection{Access Routine Semantics}
\noindent Point($Ix: \mathbb{R}, Iy: \mathbb{R}, Iz: \mathbb{R}$):
\begin{itemize}
	\item transition: x, y, z := Ix, Iy, Iz
	\item output:= self
	\item exception: N/A
\end{itemize}

\noindent .x():
\begin{itemize}
	\item output:= self.x
	\item exception: N/A
\end{itemize}

\noindent .y():
\begin{itemize}
	\item output:= self.y
	\item exception: N/A
\end{itemize}

\noindent .z():
\begin{itemize}
	\item output:= self.z
	\item exception: N/A
\end{itemize} 

\noindent distance\_abs(p:Point3D):
\begin{itemize}
	\item output:= $sqrt{(p.x-self.x)^2 + (p.y-self.y)^2 + (p.z-self.z)^2}$
	\item exception: N/A
\end{itemize} 

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Colour} \ref{mColour} \\
The Colour module captures the structure of colours used in this program.

\subsection{Template Module}
Colour

\subsection{Uses} -

\subsection{Syntax}
\subsubsection{Exported Types}
Colour = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Colour & $\mathbb{Z}^+,\mathbb{Z}^+,\mathbb{Z}^+$ & & INVALID\_R, 
		INVALID\_G, INVALID\_B \\
		.r & -- & $\mathbb{Z}^+$ & -- \\
		.g & -- & $\mathbb{Z}^+$ & -- \\		
		.b & -- & $\mathbb{Z}^+$ & -- \\		%%
		.set\_r & $\mathbb{Z}^+$ & & -- \\
		.set\_g & $\mathbb{Z}^+$ & & -- \\		
		.set\_b & $\mathbb{Z}^+$ & & -- \\		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
r : $\mathbb{Z}^+$ \\
g : $\mathbb{Z}^+$ \\
b : $\mathbb{Z}^+$ \\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\begin{itemize}
	\item Colours can be changed at any point in time - therefore setters will 
	be needed.
	\item Colours are represented by RGB values that (individually) range from 
	0 to 255.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent Colour($Ir: \mathbb{Z}^+, Ig: \mathbb{Z}^+, Ib: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: $r, g, b := Ir, Ig, Ib$
	\item exception: exc := $(r < 0 || r > 255) \implies $INVALID\_R \\
		$ | (g < 0 || g > 255) \implies $INVALID\_G \\ $| (b < 0 || b > 255) 
		\implies $INVALID\_B
\end{itemize}

\noindent .r():
\begin{itemize}
	\item output: $self.r$
	\item exception: N/A
\end{itemize}

\noindent .g():
\begin{itemize}
	\item output: $self.g$
	\item exception: N/A
\end{itemize}

\noindent .b():
\begin{itemize}
	\item output: $self.b$
	\item exception: N/A
\end{itemize} 

\noindent .set\_r($Ir: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: r := Ir
	\item exception: exc := $(r < 0 || r > 255) \implies $INVALID\_R \\
\end{itemize}

\noindent .set\_g($Ig: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: g := Ig
	\item exception: exc := $(g < 0 || g > 255) \implies $INVALID\_G \\
\end{itemize}

\noindent .set\_b($Ib: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: b := Ib
	\item exception: exc := $(b < 0 || b > 255) \implies $INVALID\_B \\
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Vector} \ref{mVector} \\
The Vector module captures the structure of Vector objects.

\subsection{Template Module}
Vector

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
Vector = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Vector\_P & Point3D, Point3D & -- & SAME\_POINTS \\
		Vector & $ \mathbb{R},\mathbb{R},\mathbb{R},\mathbb{R} $ & -- & 
		INVALID\_UX, INVALID\_UY, INVALID\_UZ, INVALID\_M \\
		.m & & $\mathbb{R}$ & -- \\
		direction & & $ \mathbb{R},\mathbb{R},\mathbb{R}$  & -- 
		\\	
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
start := Point3D \\
ux := $\mathbb{R}$ \\
uy := $\mathbb{R}$ \\
uz := $\mathbb{R}$ \\
m := $\mathbb{R}$ \\ 

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\begin{itemize}
	\item Vectors can be created infinitely; we will only set them once during 
	initialization.			
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent Vector(p:Point3D, q:Point3D):
\begin{itemize}
	\item transition: start:= p\\
	ux:= (q.x - p.x)/m \\
	uy:= (q.y - p.y)/m \\
	uz:= (q.z - p.z)/m \\
	m := start.distance\_abs(q)\\
	\item exception: exc:= \{ p == q $\implies$ SAME\_POINTS\}
\end{itemize}

\noindent Vector($Ix: \mathbb{Z}, Iy: \mathbb{Z}, Iz: \mathbb{Z}, Im: 
\mathbb{R} 
$):
\begin{itemize}
	\item transition: ux, uy, uz, m := Ix, Iy, Iz, Im
	\item exception: exc := $(ux < -1 || ux > 1) \implies $INVALID\_UX \\
	$ | (ux < -1 || ux > 1) \implies$  INVALID\_UY \\ $| $(ux $< -1 ||$ ux $> 
	1$) $\implies $ INVALID\_UZ \\ $| (m < 0) \implies$ INVALID\_M
\end{itemize}

\noindent .m():
\begin{itemize}
	\item output: $self.m$
	\item exception: N/A
\end{itemize}

\noindent direction():
\begin{itemize}
	\item output: $self.ux, self.uy, self.uz$
	\item exception: N/A
\end{itemize}

\noindent .start():
\begin{itemize}
	\item output: $self.start$
	\item exception: N/A
\end{itemize}


\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Light Type} \ref{mLightType} \\
The Light Type module is an abstract data type which captures information 
related to the different types of light sources.

\subsection{Template Module}
LightType

\subsection{Uses}
N/A

\subsection{Syntax}
\subsubsection{Exported Types}
LightType = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{7cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		LightType & \{ambient,point,spotlight,directional\} & LightType & -- \\
		.name & & LightType & -- \\
		.i & LightType & $\mathbb{R},\mathbb{R} \to 
		\mathbb{R}$ & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
name := \{ ambient, point, spotlight, directional \} \\
i := Function that describes how the light intensity changes as a function of 
distance. Every type of light has an associated function - so this should 
really be a set of functions.\\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent LightType(inName):
\begin{itemize}
	\item transition: self.name := inName \\
					  self.i := (name == ambient $\implies \lambda d, i_{0} \to 
					  i_{0}$ \\
					  $|$  name == directional $\implies \lambda d, i_{0} \to 
					  \frac{1}{d^2}i_{0}$ \\
					  $|$ name == point $\implies \lambda d, i_{0} \to 
					  i_{0}$\\
					  $|$ name == spotlight $\implies$)
	\item output: self
	\item exception: exc:= \{inName $\notin$ {ambient, spotlight, point, 
	directional} $\implies$ INVALID\_LIGHT\_TYPE \}
\end{itemize}

\noindent .name():
\begin{itemize}
	\item output: $self.name$
	\item exception: N/A
\end{itemize}

\noindent .i():
\begin{itemize}
	\item output: $self.i$
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Polygon} \ref{mPolygon} \\
The Polygon module is an abstract data type captures the structure of polygons 
used in polygon meshes.

\subsection{Template Module}
Polygon

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
Polygon = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{7cm} p{5cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Polygon & \{triangle, quad\}, (Point3D, Vector)$^n$ & -- & -- \\
		.shape & -- & \{triangle, quad\} & -- \\
		.bounds & -- & Set of (Point3D, Vector) & -- \\
		.s\_norm & -- & Vector & -- \\
		getEdges & Point3D & Set of Vectors & -- \\
		getPoints & & Set of Point3D & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
shape := \{triangle, quad\}\\
bounds := Set of (Point3D, Vector) tuples\\
s\_norm := Vector\\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent Polygon($t:\{triangle, quad\}, (p:Point3D, v:Vector)^n$):
\begin{itemize}
	\item transition:= $shape := t;$ \\
	$bounds := \cup (p,v)$ \\
	s\_norm := Calculate norm as cross-product of two vectors from 1 vertex.
	\item exception: exc := \{(t $\notin$ \{triangle, quad\} $\implies$ 
	INVALID\_SHAPE) \\ $|$ (t:\{triangle, quad\},b: Set of (Point3D, Vector)$|$ 
	t == triangle, sizeOfBounds $<$ 6 $\implies$ TOO\_FEW\_POINTS) \\ $|$ 
	(t:\{triangle, quad\},b: Set of (Point3D, Vector) $|$ t == triangle, 
	sizeOfBounds $>$ 6 $\implies$ TOO\_MANY\_POINTS) \\ $|$ 
	(t:\{triangle, quad\},b: Set of (Point3D, Vector) $|$ t == quad, 
	sizeOfBounds $>$ 8 $\implies$ TOO\_MANY\_POINTS) \\ $|$ 
	(t:\{triangle, quad\},b: Set of (Point3D, Vector) $|$ t == quad, 
	sizeOfBounds $<$ 8 $\implies$ TOO\_FEW\_POINTS)  \}\\
\end{itemize}

\noindent .shape():
\begin{itemize}
	\item output:= self.shape
	\item exception: N/A
\end{itemize}

\noindent .bounds():
\begin{itemize}
	\item output:= self.bounds
	\item exception: N/A
\end{itemize}

\noindent .s\_norm():
\begin{itemize}
	\item output:= self.s\_norm
	\item exception: N/A
\end{itemize}

\noindent getEdges(p:Point3D):\\
This method retrieves all the edges that are connected to the vertex 
represented by Point3D p. Individual polygons should have a maximum of two 
edges per vertex based on the polygon assumptions.\\
\begin{itemize}
	\item output:= Set of Vectors := $\forall b : (Point3D,Vector) | (b \in 
	self.bounds \wedge b[0] == p) \implies \cup b[1] $
	\item exception: N/A
\end{itemize}

\noindent getPoints():\\
This method retrieves the set of points in the polygon.\\
\begin{itemize}
	\item output: Set of Point3D := $b: (Point3D, Vector)| \forall b \in 
	self.bounds  \cup b.[0]$
	\item exception: N/A
\end{itemize}


\subsubsection{Local Functions}
sizeOfBounds $\equiv$ Number of elements in the set of (Point3D, Vector) 
tuples.\\

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

%%---------------------------------Complex Types--------------------------------
%%These are just the types that rely on the beasic types but are closer in 
%%detail to the problem we're trying to describe.

\section{MIS of Mesh} \ref{mMesh} \\
The Mesh module is an abstract data type that captures the structure of polygon 
meshes as used by this program. It also provides methods to find out basic data 
about the polygon mesh.

\subsection{Template Module}
Mesh

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
Mesh = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Mesh & Set of Polygons & -- & -- \\
		.Surfaces & - & Set of Polygons & -- \\
		.Edges & - & Set of Vectors & -- \\
		.Vertices & - & Set of Point3D & -- \\
		isInMesh & Polygon & $\mathbb{B}$ & -- \\ %Check whether the given 
		%polygon is part of the mesh
		numPoly & Point3D & $\mathbb{Z^+}$ & -- \\ %Given a vertex, count how 
		%many polygons that vertex is attached to.
		intersects & Vector & Polygon & -- \\ %Given a vector (e.g. a ray) 
		%calculate the polygon that it intersects with in that mesh
		pointsOnMesh & Point3D & $\mathbb{B}$ & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
Vertices : Set of Point3D\\
Edges : Set of Vectors\\
Surfaces : Set of Polygons\\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent Mesh($P:Set of Polygons$):
\begin{itemize}
	\item transition: Surfaces := P
	Vertices := $(p:Polygon | \forall p \in P \to \cup p.getPoints)$\\
	(Vertices pulls its values from the bounds of the polygons in P)\\
	Edges := $(p:Polygon, v:Point3D | \forall p \in P \forall v \in p.getPoints 
	\cup (p.getEdges(v)))$\\
	(Edges pulls its values from the bounds of the polygons in P)\\
	\item exception: exc := \{ P == $\emptyset \implies$ INVALID\_MESH\\ $| 
	(p,q:Polygon| \forall p, q \in P, p \neq q \land p.shape \neq q.shape 
	\implies$ POLYGON\_SHAPES\_MISMATCH)\\ $| (p,q:Polygon, 
	p_{1},q_{1}:Point3D| 
	\forall p \in P, \exists q \in P$ such that $\exists p_{1} \in 
	p.getPoints() 
	\land \exists q_{1} \in q.getPoints()$ such that $p_{1} \neq q_{1} 
	\implies$ 
	INVALID\_POLYS)\}
	
\end{itemize}

\noindent .Surfaces():
\begin{itemize}
	\item output := self.Surfaces
	\item exception: N/A
\end{itemize}

\noindent .Vertices():
\begin{itemize}
	\item output := self.Vertices
	\item exception: N/A
\end{itemize}

\noindent .Edges():
\begin{itemize}
	\item output := self.Edges
	\item exception: N/A
\end{itemize}

\noindent isInMesh($p:Polygon$):
\begin{itemize}
	\item output := $(q:Polygon|\exists q \in self.Surfaces where q == p)$
	\item exception: N/A
\end{itemize}

\noindent numPoly($p:Point3D$):
\begin{itemize}
	\item output:=  counter := $p \in$ self.Vertices $\implies (s:Polygon| 
	\forall s \in$ self.Surfaces) if $p \in s.bounds$ then $counter++$
	\item exception: exc := $\{p \notin self.Vertices \implies$ 
	ERR\_POINT\_NOT\_IN\_MESH\}
\end{itemize}

\noindent intersects($r:Vector$):
\begin{itemize}
	\item output := calculate whether the given vector intersects with any 
	polygon on the mesh, and return the first polygon it intersects with.
	\item exception: exc :=
\end{itemize}

\noindent pointsOnMesh(p: Point3D):
\begin{itemize}
	\item output := return true if p is a point on a polygon in the mesh.
	\item exception: exc :=
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of LightSources} \ref{mLightSource} \\
The Light Source module is an Abstract Data Type that defines the structure and 
behaviours of light sources in the scene.
\subsection{Template Module}
LightSource

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
LightSource = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{7cm} p{2cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		LightSource & Point3D, Colour, LightType, $\mathbb{R}$, Set of Vectors 
		& 
		LightSource & \\
		.origin & & Point3D & \\
		.colour & & Colour & \\
		.type & & LightType & \\
		.intensity & & $\mathbb{R}$ & \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
o: Point3D \\ %%Origin position of light source
c: Colour \\
t: lightType \\
$i_{0}$: $\mathbb{R}$ \\
ds: Set of Vector \\ %%Set of direction vectors 

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}

\noindent LightSource(inP: Point3d, inC: Colour, lt: LightType, ins: 
$\mathbb{R}$ inDs: Set of Vectors):
\begin{itemize}
	\item transition: o, c, t, i, ds := inP, inC, lt, ins, inDs
	\item exception: N/A
\end{itemize}

\noindent .origin():
\begin{itemize}
	\item output:= self.o
	\item exception: N/A
\end{itemize}

\noindent .colour():
\begin{itemize}
	\item output:= self.c
	\item exception: N/A
\end{itemize}

\noindent .type():
\begin{itemize}
	\item output:= self.t
	\item exception: N/A
\end{itemize}

\noindent .intensity():
\begin{itemize}
	\item output: self.i
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Observer} \ref{mObserver} \\
The Observer Module is an Abstract Data Type which captures information related 
to the camera in a scene. While there's no behaviour and this type of 
information could be represented as an Abstract Object since there's only one 
at any time in the scene, I'm attempting to future proof the design by keeping 
it an Abstract Data Type.

\subsection{Template Module}
Observer

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
Observer = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Observer & Point3D, Vector & Observer & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
p : Point3D\\
d : Vector\\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
There is only one observer in the scene at any time. This might change in 
future versions of this software, but as it exists we're only looking at the 
objects from one view.

\subsubsection{Access Routine Semantics}
\noindent Observer(inP: Point3D, inD : Vector):
\begin{itemize}
	\item transition: p := inP \\
	d := inD
	\item output := self
	\item exception: exc :=
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of NormalMap} \ref{mNormalMap} \\
The NormalMap module is an Abstract Data Type which captures information about 
the normal maps of an object mesh. This information is necessary for 
calculating reflections and is easier to calculate once and store instead of 
calculating on the fly.

\subsection{Template Module}
NormalMap

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
NormalMap = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		NormalMap & Set of (Point3D, Vector) & NormalMap & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
NormalMap = Set of (Point3D, Vector)

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}


\subsubsection{Access Routine Semantics}
\noindent NormalMap(ns : (Point3D,Vector)):
\begin{itemize}
	\item transition: p := inP \\
	d := inD
	\item output := self
	\item exception: exc :=
\end{itemize}

\noindent getNormal(p:Point3D):
\begin{itemize}
	\item output := 
	\item exception: exc :=
\end{itemize}


\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Object} \ref{mObjects} \\
The Object module is an abstract data type that captures the structure of 
objects in the scenes defined by this program.

\subsection{Template Module}
Object

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
Object = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		
		\multirow{10}{*}{Object} & Mesh, & Object & \\
		& Point3D, & & \\
		& $\mathbb{R}$, & & \\  
		& Colour, & & \\
		& Colour, & & \\
		& $\mathbb{Z},$ & & \\
		& $\mathbb{Z},$ & & \\
		& $\mathbb{Z},$ & & \\
		& $\mathbb{N},$ & & \\
		& \{FLAT, GOURAUD, PHONG\} & & \\		
		%%Getters
		.Mesh & - & Mesh & - \\
		.Position & - & Point3D & - \\
		.Size &- & $\mathbb{Z}$ & \\
		.BaseColour &- & Colour & \\
		.SpecColour &- & Colour & \\
		.kd &- & $\mathbb{R}$ & \\
		.ka &- & $\mathbb{R}$& \\
		.ks &- & $\mathbb{R}$ & \\
		.alpha &- & $\mathbb{N}$ & \\
		.nmap &- & NormalMap& \\ 
		%%Setters
		SetObj\_Position & Point3D & - & \\
		SetObj\_Size & $\mathbb{R}$ & - & \\
		SetObj\_BaseColour & Colour &- & \\
		SetObj\_SpecColour & Colour &- & \\
		SetObj\_kd & $\mathbb{R}$ &- & IV\_OUT\_OF\_BOUNDS\\
		SetObj\_ka & $\mathbb{R}$&- & IV\_OUT\_OF\_BOUNDS\\
		SetObj\_ks & $\mathbb{R}$ &- & IV\_OUT\_OF\_BOUNDS\\
		SetObj\_alpha & $\mathbb{Z}^+$ &- & IV\_OUT\_OF\_BOUNDS\\
		SetObj\_NormalMap & $nMap$ &- &- \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
baseColour : Colour \\
specColour : Colour \\
centrePoint : Point3D \\
mesh : Mesh \\
ka : $\mathbb{R}$ \\
ks : $\mathbb{R}$ \\
kd : $\mathbb{R}$ \\
alpha : $\mathbb{Z}^+$ \\
nMap : NormalMap \\
size : $\mathbb{R}$\\
shade : \{FLAT, GOURAUD, PHONG\}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent Object(inM: Mesh, inP : Point3D, inSize : 
$\mathbb{R}$,  inBase : Colour, inSpec : Colour, inD : $\mathbb{Z}$, inA : 
$\mathbb{R}$, inS : $\mathbb{R}$, inAlpha : $\mathbb{N}$, inShade : \{FLAT, 
GOURAUD, PHONG\}):
\begin{itemize}
	\item transition: mesh, baseColour, specColour, centrePoint, ka, kd, ks, 
	alpha, size := inM, inBase, inSpec, inP, inA, inD, inS, inAlpha, inSize\\
	nMap := Shader.findNormals(shade, self)
	\item exception: N/A
\end{itemize}

\noindent .Mesh():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.m
	\item exception: N/A
\end{itemize}

\noindent .Position():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.centrePoint
	\item exception: N/A
\end{itemize}

\noindent .Size():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.size
	\item exception: N/A
\end{itemize}

\noindent .BaseColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.baseColour
	\item exception: N/A
\end{itemize}

\noindent .SpecColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.specColour
	\item exception: N/A
\end{itemize}

\noindent .kd():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.kd
	\item exception: N/A
\end{itemize}

\noindent .ka():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.ka
	\item exception: N/A
\end{itemize}

\noindent .ks():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.ks
	\item exception: N/A
\end{itemize}

\noindent .alpha():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: self.alpha
	\item exception: N/A
\end{itemize}

\noindent .NormalMap():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.nMap
	\item exception: N/A
\end{itemize}
%%Setters
\noindent SetObj\_Position(p: Point3D):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: centrePoint := p
	\item exception: N/A
\end{itemize}

\noindent SetObj\_Size(s : $\mathbb{R}$):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: size := s
	\item exception: N/A
\end{itemize}

\noindent SetObj\_BaseColour(c : Colour):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: baseColour := c
	\item exception: exc := {\\
					c.r > 255 $\implies$ IV\_OUT\_OF\_BOUNDS\\
					$|$ \\
					c.g > 255 $\implies$ IV\_OUT\_OF\_BOUNDS \\
					$|$ \\
					c.b > 255 $\implies$ IV\_OUT\_OF\_BOUNDS\\
					$|$ \\
					c.r < 1 $\implies$ IV\_OUT\_OF\_BOUNDS\\
					$|$ \\
					c.g < 1 $\implies$ IV\_OUT\_OF\_BOUNDS \\
					$|$ \\
					c.b < 1 $\implies$ IV\_OUT\_OF\_BOUNDS}	\\	
\end{itemize}

\noindent SetObj\_SpecColour(c : Colour):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: specColour := c
	\item exception: exc := {\\
					c.r > 255 $\implies$ IV\_OUT\_OF\_BOUNDS\\
					$|$ \\
					c.g > 255 $\implies$ IV\_OUT\_OF\_BOUNDS \\
					$|$ \\
					c.b > 255 $\implies$ IV\_OUT\_OF\_BOUNDS	\\
					$|$ \\
					c.r < 1 $\implies$ IV\_OUT\_OF\_BOUNDS\\
					$|$ \\
					c.g < 1 $\implies$ IV\_OUT\_OF\_BOUNDS \\
					$|$ \\
					c.b < 1 $\implies$ IV\_OUT\_OF\_BOUNDS}	\\	 
\end{itemize}

\noindent SetObj\_kd(d: $\mathbb{R}$):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: kd := d
	\item exception: exc := {\\
		d > 1 $\implies$ COEFFICIENT\_TOO\_HIGH\\
		d < 0.5 $\implies$ COEFFICIENT\_TOO\_LOW\\}
\end{itemize}

\noindent SetObj\_ka(a: $\mathbb{R}$):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: ka := a
	\item exception: exc := {\\
		a > 1 $\implies$ COEFFICIENT\_TOO\_HIGH\\
		a < 0 $\implies$ COEFFICIENT\_TOO\_LOW\\}
\end{itemize}

\noindent SetObj\_ks(s: $\mathbb{R}$):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: ks := s
	\item exception: exc := {\\
		s > 1 $\implies$ COEFFICIENT\_TOO\_HIGH\\
		s < 0 $\implies$ COEFFICIENT\_TOO\_LOW\\}
\end{itemize}

\noindent SetObj\_alpha(al: $\mathbb{N}$):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: alpha := al
	\item exception: exc := {\\
		a < 0 $\implies$ COEFFICIENT\_TOO\_LOW\\}
\end{itemize}

\noindent SetObj\_NormalMap():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: A normal map of the object. This is a list of normals based 
	on shader calculations, and a string literal that describes the type of 
	normals (vertex, surface, pixel).
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Scene Module} \ref{mScene} \\
The Scene Module is an abstract object module that contains the structure for 
the overall scene. It maintains information about the entities in the scene 
(object, light source, observer) regarding their distances between each other. 
It constrains the positions, sizes, and directions of entities based on the 
specified size of the scene.
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Scene

\subsection{Uses}
Input, Output

\subsection{Syntax}
\subsubsection{Exported Constants}
SCENE\_MAX\_H : $\mathbb{R}^+$\\
SCENE\_MIN\_H : $\mathbb{R}^+$\\
SCENE\_MAX\_W : $\mathbb{R}^+$\\
SCENE\_MIN\_W : $\mathbb{R}^+$\\
SCENE\_MAX\_D : $\mathbb{R}^+$\\
SCENE\_MIN\_D : $\mathbb{R}^+$\\
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{7}{4cm}{initScene} & $\mathbb{R}^+$ & Scene & 
		HEIGHT\_TOO\_SMALL, 
		HEIGHT\_TOO\_LARGE\\
		& $\mathbb{R}^+$ & & WIDTH\_TOO\_SMALL, 
		WIDTH\_TOO\_LARGE\\		
		& $\mathbb{R}^+$ & & DEPTH\_TOO\_SMALL, 
		DEPTH\_TOO\_LARGE\\				 
		& Object & & INVALID\_OBJECT\_POSITION\\				 
		& LightSource & & INVALID\_LIGHT\_POSITION\\
		& Observer & & INVALID\_OBSV\_POSITION\\
		& \{DIFFUSE, HALF-LAMBERT, PHONG, BLINN-PHONG\} & & \\
		
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
height : $\mathbb{R}$\\
width : $\mathbb{R}$\\
depth : $\mathbb{R}$\\
obs : Observer \\
ls : LightSource \\
os : Object\\
lightModel : \{DIFFUSE, HALF-LAMBERT, PHONG, BLINN-PHONG\}

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
\noindent initScene($h: \mathbb{R}, w: \mathbb{R}, d: \mathbb{R}$, o: Object, 
l: LightSource, ob: Observer, lm: \{DIFFUSE, HALF-LAMBERT, PHONG, 
BLINN-PHONG\}):
\begin{itemize}
	\item transition: height, width, depth, obs, ls, os, lightModel := h, w, d, 
	ob, l, o, lm
	\item output := self
	\item exception: exc := \{(h $\le$ SCENE\_MIN\_H $\implies$ 
	HEIGHT\_TOO\_SMALL) \\
	$|$ (h $\ge$ SCENE\_MAX\_H $\implies$ HEIGHT\_TOO\_LARGE) \\
	$|$ (w $\le$ SCENE\_MIN\_W $\implies$ WIDTH\_TOO\_SMALL) \\
	$|$ (w $\ge$ SCENE\_MAX\_W $\implies$ WIDTH\_TOO\_LARGE) \\
	$|$ (d $\le$ SCENE\_MIN\_D $\implies$ DEPTH\_TOO\_SMALL) \\
	$|$ (d $\ge$ SCENE\_MAX\_D $\implies$ DEPTH\_TOO\_LARGE) \\
	$|$ ($\not$ (objectInScene(o)) $\implies$	INVALID\_OBJECT\_POSITION \\
	$|$ ($\not$ (lightInScene(l)) $\implies$	INVALID\_LIGHT\_POSITION \\	
	$|$ ($\not$ (obsvInScene(obs)) $\implies$	INVALID\_OBSV\_POSITION \\		
	\}
\end{itemize}

\subsubsection{Local Functions}
objectInScene(o : Object) $\equiv$ (SCENE\_MIN\_H < o.position.y < 
SCENE\_MAX\_H) 
$\land$ (SCENE\_MIN\_W < o.position.x < SCENE\_MAX\_W) $\land$ 
(SCENE\_MIN\_D < o.position.z < SCENE\_MAX\_D) \\
~\newline
lightInScene(l : LightSource) $\equiv$ (SCENE\_MIN\_H < l.position.y < 
SCENE\_MAX\_H) 
$\land$ (SCENE\_MIN\_W < l.position.x < SCENE\_MAX\_W) $\land$ 
(SCENE\_MIN\_D < l.position.z < SCENE\_MAX\_D)\\
~\newline
obsvInScene(o : Observer) $\equiv$ (SCENE\_MIN\_H < o.position.y < 
SCENE\_MAX\_H) 
$\land$ (SCENE\_MIN\_W < o.position.x < SCENE\_MAX\_W) $\land$ 
(SCENE\_MIN\_D < o.position.z < SCENE\_MAX\_D) \\

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

%%---------------------------------Libraries------------------------------------
\section{MIS of VecMath} \ref{mVecMath} \\
The Vector Math module is a library of services that can be used with Vectors. 
All functions here take in 2 Vectors and output either a Vector or a scalar 
value.

\subsection{Module}
VecMath

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}
N/A
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		add & Vector, Vector & Vector & -- \\
		sclMult & Vector, $\mathbb{R}$ & Vector & -- \\ 
		dot & Vector, Vector & $\mathbb{R}$ & -- \\
		cross & Vector, Vector & Vector & -- \\
		angleBetween & Vector, Vector & rad & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent add($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: 
	Vector((v1.x+v2.x),(v1.y+v2.y),(v1.z,v2.z), \\
	$\sqrt{(v1.x+v2.x)^2+(v1.y+v2.y)^2+(v1.z,v2.z)^2}$)
	\item exception: exc := \\
\end{itemize}

\noindent sclMult($v1:Vector, r:\mathbb{R}$):
\begin{itemize}
	\item output: 
	ux := $r \times v1.x$ \\
	uy := $r \times v1.y$ \\
	uz := $r \times v1.z$ \\	
	\item exception: \\
\end{itemize}


\noindent dot($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: 
	ux := $v1.x \times v2.x$ \\
	uy := $v1.y \times v2.y$ \\
	uz := $v1.z \times v2.z$ \\
	\item exception: \\
\end{itemize}

\noindent cross($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: 
	ux := $(v1.y \times v2.z) - (v1.z \times v2.y)$  \\
	uy := $(v1.z \times v2.x) - (v1.x \times v2.z)$  \\
	uz := $(v1.x \times v2.y) - (v1.y \times v2.x)$  \\
	\item exception: \\
\end{itemize}

\noindent angleBetween($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: $\cos^{-1}(\frac{dot(v1, v2)}{v1.m \times v2.m})$
	\item exception: \\
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Shader} \ref{mShader} \\

\subsection{Module}
Shader

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}
N/A
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		interpolate & (Point3D, Vector), (Point3D, Vector), Point3D & Vector & 
		-- \\
		findNormals & ShadingModel, Object & NormalMap & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent interpolate(s: (Point3D, Vector), e: (Point3D, Vector), p: Point3D):
\begin{itemize}
	\item output:= Linear interpolation of normal values between starting 
	vertex (s[0]) and ending vertex (s[1]).\\
	\item exception: \\
\end{itemize}

\noindent findNormals(s:ShadingModel, o:Object):
\begin{itemize}
	\item output: ns : NormalMap :=
	(s == FLAT $\implies$ all points on the mesh have a normal equal to their 
	polygon's surface normal.\\
	\textit{$\forall$ q:Point3D, $\exists$ p:Polygon $|$ q $\in$ p.getPoints() 
	$\land$ p $\in$ o.Mesh.Surfaces() $\to$ (q,p.s\_norm)\\} 
	\\
	$|$ s == GOURAUD $\implies$ all vertices on the mesh have a normal equal to 
	the average of the surface normals of the polygons they are a part of. The 
	normals of the points in between the vertices are not calculated.\\
	\textit{$\forall$ v : Point3D $|$ v $\in$ o.Mesh.Vertices() $\to \forall$ p 
	: Polygon $|$ v $\in$ p.getPoints() \\
	\textit{begin:}
	\begin{itemize}
		\item[] sum:= +(p.s\_norm) --- \textit{Add the surface norms 
			together}.
		\item[] counter++ --- \textit{Count how many polygons are a part of 
			this}.
	\end{itemize}
	\textit{end} $\to$ (v, sum/counter)}\\
	%%Gouraud shading takes sets the normal at the vertex to be the average of 
	%%the surface normals for all the polygons that vertex is a part of. It 
	%%then calculates the colour at the vertices and interpolates the colours 
	%%between vertices.
	\\
	$|$ s == PHONG $\implies$ all vertices on the mesh have a normal equal to 
	the average of the surface normals of the polygons they are a part of. The 
	normals of the points in between the vertices of a polygon are calculated 
	by interpolating their values between the vertices.\\
	\textit{begin:
	\begin{enumerate}
		\item ns := ns $\cup$ ($\forall$ v : Point3D $|$ v $\in$ 
		o.Mesh.Vertices() 
		$\to$ $\forall$ p : Polygon $|$ v $\in$ p.getPoints() \\
		\textit{begin:}
		\begin{itemize}
			\item[] sum:= +(p.s\_norm) --- \textit{Add the surface norms 
				together}.
			\item[] counter++ --- \textit{Count how many polygons are a part of 
				this}.
		\end{itemize}
		\textit{end} $\to$ (v, sum/counter))
		\item ns := ns $\cup$ ($\forall$ start, end, p : Point3D $|$ start, 
		end, p $\in$ o.Mesh.pointsOnMesh() $\land$ start, end $\in$ 
		o.Mesh.Vertices() $\land$ p $\notin$ o.Mesh.Vertices() $\to$ (p,
		interpolate((start,), (end, ), p)))
	\end{enumerate}
	end\\}
	%%Phong shading sets the vertex normals to be the average of the surface 
	%%normals for all the polygons that vertex is a part of.
	)
	
	\item exception: exc := \\
\end{itemize}


\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage











\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}