\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument[CA-]{../../Commonality-Analysis/CA}
\externaldocument[MG-]{../MG/MG}

\input{../../Comments}

\newcommand{\progname}{Lighting Models}

\begin{document}

\title{Module Interface Specification for Lighting Models}\label{mis}

\author{Sasha Soraine}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
November 29 2019 & 1.0 & Submitted Document to GitHub after extension\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{../Commonality-Analysis/CA.pdf}

%%\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\progname. %\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/sorainsm/library-of-lighting-models}.  
%\wss{provide the url for your repo}

\section{Notation}

%\wss{You should describe your notation.  You can use what is below as
% a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
3D Cartesian Coordinate & Point3D &  A 3-dimensional cartesian coordinate, 
represented as an (x,y,z)-tuple where all three are $\mathbb{R}$ values\\
RGB Colour & Colour &  A 3-tuple represented as (r,g,b)- where all three are 
$\mathbb{R}$ values\\
Shape of Object & Shape & The abstract shape that an object mesh is classified 
as. It can be one of the following : sphere, cube, torus, teapot. \\
Polygon Mesh & Mesh & Mesh constructed of vertices, edges, and traingle 
surfaces to create one of the allowed shapes.\\
Normal Map of Object & nMap & A structure maintaining a list of the normal 
vectors for the measured points on the mesh. \\
\bottomrule
\end{tabular} 
\end{center}

\wss{There is already an issue about this, but I'm mention again that types like
  RGB Colour cannot really be primitive data types.  They'll need to be defined
  in the MIS.}

\noindent
The specification of \progname uses some derived data types: sequences, 
strings, and tuples. Sequences are lists filled with elements of the same data 
type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & ~ \\
		\midrule
		
		\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Input Parameters 
		Module\\
		%%Purpose of the input parameters module is to parse the JSON file and 
		%%separate 
		%%it into usable objects
		& Output Format Module \\
		%% Purpose is to create the output of the module
		& Polygon Module\\
		& Colour Module\\
		& 3D Cartesian Coordinate (Point3D) Module\\ %%Data type for 
		%%representing 
		%%cartesian 
		%%coordinates; works with the vector math module to define vectors and 
		%%calculate 
		%%things
		& Polygon Mesh Module\\ %I'm not reinventing the wheel with this 
		%module; people 
		%smarter than me have implemented polygon mesh libraries and data 
		%structures.
		& Normal Maps Module\\ %I'm not reinventing the wheel with this module; 
		%people 
		%smarter than me have implemented vector calculus.
		& Scene Module\\
		%% Data type definition of a scene in this program
		& Object Module\\
		%% Data type definition of an object in this program
		& Light Source Module\\
		%% Data type definition of a light source in this program
		& Observer Module \\
		%% Data type definition of an observer in this program
		& Vector Math Module\\ %I'm not reinventing the wheel with this module; 
		%people 
		%smarter than me have implemented vector calculus.
		& Shader Module\\
		& Lighting Model Module\\
		\midrule
		\multirow{2}{0.3\textwidth}{Software Decision Module} 
		& JSON Module\\ %I need the JSON module to parse and write JSON files
		& Rendering Module\\ %Rationale: The outputted JSON file will be passed 
		%back to 
		%unity for rendering
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

~\newpage

The following sections of this document will outline the module interface 
specifications for the modules listed in the module hierarchy. Three modules 
are omitted from this discussion: the hardware-hiding module, the JSON module, 
and the rendering module. The hardware hiding module is provided via the syntax 
of the programming language to interface with the computer hardware, as such I 
will not be documenting it here. The JSON and rendering module will be handled 
natively by the Unity environment, the process of documenting how it would work 
wouldn't be appropriate for the scope of this work. Suffice it to say that the 
documentation for the rendering module can be found in the documentation for 
the Unity Engine.

%% -------------------------File Related Modules--------------------------------
\section{MIS of Input Parameters Module} \ref{MG-mInputs} \\
\wss{Please add a makefile for building the documents so that the
  cross-references between documents can be kept up to date.  The module
  reference number without an introduction is confusing.  Even putting an M in
  front of it would help identify it as a module.}  The Input Parameters Module
converts the JSON data from the input file into the objects usable by the
system. During this process, the input is read as a string into the system from
the file and passed through the JSON module to parse them.

\subsection{Module}
Input Parameters

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		loadFile & String & - & INVALID\_FILE\_NAME, INVALID\_FILE\_TYPE, 
		FILE\_EMPTY\\
		\multirow{4}{*}{convertJSONtoScene} & \multirow{4}{2cm}{JSON File} & s: 
		Scene & \\
		& & o : Object & \\
		& & l : LightSource & \\
		& & v : Observer & \\
		%%
		\hline
	\end{tabular}
\end{center}

\wss{Where are the types Object, LightSource etc. defined?  This is what the
  Uses clause is for.  You can tell the reader where they can find the details
  they need to understand the specification of this module.}

\subsection{Semantics}
\subsubsection{State Variables}
loaded : String %%JSON contents of file read as string

\subsubsection{Environment Variables}
input: File
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
\noindent loadFile(f:String):
\begin{itemize}
	\item transition: loaded := ReadFile(f) \wss{You should make the
            connection that the filename f refers the the environment variable input.}
	\item exception: exc := \{f does not exist $\implies$ INVALID\_FILE\_NAME\\
	$|$ f $\to$ input $\land$ input is not a JSON file $\implies$ 
	INVALID\_FILE\_TYPE\\
	$|$ ReadFile(f) outputs an empty string $\implies$ FILE\_EMPTY
	\}
\end{itemize}

\noindent convertJSONtoScene(): \wss{Without knowing the types, I cannot
  understand what is happening here.  I can see why you would not want to get
  into the details of the JSON format, but you should point to a reference
  (probably in Unity) that tells the readers the connection between the file and
  the outputs.}

\begin{itemize}
	\item output:= s : initScene, o : Object, l : LightSource , v: Observer 
	%%The 
	%%scene will check whether the positional information 
	%%is valid.
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Output Parameters Module} \ref{MG-mOutputs} \\
The Output Parameters Module converts the data from the scene into JSON 
formatted data.

\subsection{Module}
Output Parameters

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
OutputObject = ? \wss{You use this notation for ADTs, but I do not get the
  impression that this is what you mean here.  For an ADT the word Template
  should be in the heading.  Also, ADTs have constructors.  You only have one
  access program and it a constructor.}

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		convert & Scene, String & - & INVALID\_FILE\_NAME, NO\_DATA\_TO\_WRITE\\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
writing : (Scene, Object, LightSource, Observer)%%JSON contents of file read as 
%%string
\wss{The notation used here is not the Hoffman and Strooper notation.  Is this a
  tuple?  What are the field variables and what are the types?  If these are
  types, where are they defined?}

\subsubsection{Environment Variables}
output: File
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
\noindent convert(s: Scene, o: String):
\begin{itemize}
	\item transition: writing := (s, s.os, s.ls, s.obs)
	\item output: output := OpenFile(o) and ToJSON(writing)
	\item exception: exc := \{o already exists $\implies$ INVALID\_FILE\_NAME\\
	$|$ writing is empty $\implies$ NO\_DATA\_TO\_WRITE \\
	\}
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

%% -----------------------------Basic Types---------------------------------
\section{MIS of Point3D} \ref{MG-mPoints} \\
The Point3D module captures the structure of a 3D Caretsian Coordinate and 
functions that are useful for this structure.

\subsection{Template Module}
Point3D

\subsection{Uses} -

\subsection{Syntax}
\subsubsection{Exported Types}
Point3D = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Point & $\mathbb{R}, \mathbb{R}, \mathbb{R}$ & Point3D & -- \\
		.x & -- & $\mathbb{R}$ & -- \\
		.y & -- & $\mathbb{R}$ & -- \\		
		.z & -- & $\mathbb{R}$ & -- \\
		distance\_abs & Point3D & $\mathbb{R}$ & -- \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
x : $\mathbb{R}$ \\
y : $\mathbb{R}$ \\
z : $\mathbb{R}$ \\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
Point3D positions (x,y,z) are only set once (at initialization). This means 
there will be no individual setter methods.

We assume that all the routines can only be called after Point() has been 
called once. This means there needs to be at least one Point3D before you can 
call other routines.

\subsubsection{Access Routine Semantics}\label{mPoints-programs}
\noindent Point($Ix: \mathbb{R}, Iy: \mathbb{R}, Iz: \mathbb{R}$):
\begin{itemize}
	\item transition: x, y, z := Ix, Iy, Iz
	\item output:= self
	\item exception: N/A
\end{itemize}

\noindent .x():
\begin{itemize}
	\item output:= self.x
	\item exception: N/A
\end{itemize}

\noindent .y():
\begin{itemize}
	\item output:= self.y
	\item exception: N/A
\end{itemize}

\noindent .z():
\begin{itemize}
	\item output:= self.z
	\item exception: N/A
\end{itemize} 

\noindent distance\_abs(p:Point3D):
\begin{itemize}
	\item output:= $\sqrt{(p.x-self.x)^2 + (p.y-self.y)^2 + (p.z-self.z)^2}$
	\item exception: N/A
\end{itemize} 

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\wss{The Point3D ADT looks good.}

\newpage

\section{MIS of Colour} \ref{MG-mColour} \\
The Colour module captures the structure of colours used in this program.
\wss{This module looks fine.}

\subsection{Template Module}
Colour

\subsection{Uses} -

\subsection{Syntax}
\subsubsection{Exported Types}
Colour = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Colour & $\mathbb{Z}^+,\mathbb{Z}^+,\mathbb{Z}^+$ & & INVALID\_R, 
		INVALID\_G, INVALID\_B \\
		.r & -- & $\mathbb{Z}^+$ & -- \\
		.g & -- & $\mathbb{Z}^+$ & -- \\		
		.b & -- & $\mathbb{Z}^+$ & -- \\		%%
		.set\_r & $\mathbb{Z}^+$ & & -- \\
		.set\_g & $\mathbb{Z}^+$ & & -- \\		
		.set\_b & $\mathbb{Z}^+$ & & -- \\		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
r : $\mathbb{Z}^+$ \\
g : $\mathbb{Z}^+$ \\
b : $\mathbb{Z}^+$ \\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\begin{itemize}
	\item Colours can be changed at any point in time - therefore setters will 
	be needed.
	\item Colours are represented by RGB values that (individually) range from 
	0 to 255.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent Colour($Ir: \mathbb{Z}^+, Ig: \mathbb{Z}^+, Ib: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: $r, g, b := Ir, Ig, Ib$
	\item exception: exc := $(r < 0 || r > 255) \implies $INVALID\_R \\
		$ | (g < 0 || g > 255) \implies $INVALID\_G \\ $| (b < 0 || b > 255) 
		\implies $INVALID\_B
\end{itemize}

\noindent .r():
\begin{itemize}
	\item output: $self.r$
	\item exception: N/A
\end{itemize}

\noindent .g():
\begin{itemize}
	\item output: $self.g$
	\item exception: N/A
\end{itemize}

\noindent .b():
\begin{itemize}
	\item output: $self.b$
	\item exception: N/A
\end{itemize} 

\noindent .set\_r($Ir: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: r := Ir
	\item exception: exc := $(r < 0 || r > 255) \implies $INVALID\_R \\
\end{itemize}

\noindent .set\_g($Ig: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: g := Ig
	\item exception: exc := $(g < 0 || g > 255) \implies $INVALID\_G \\
\end{itemize}

\noindent .set\_b($Ib: \mathbb{Z}^+$):
\begin{itemize}
	\item transition: b := Ib
	\item exception: exc := $(b < 0 || b > 255) \implies $INVALID\_B \\
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Vector} \ref{MG-mVectors} \\
The Vector module captures the structure of Vector objects.

\subsection{Template Module}
Vector

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
Vector = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Vector\_P & Point3D, Point3D & -- & SAME\_POINTS \\
		Vector & $ \mathbb{R},\mathbb{R},\mathbb{R},\mathbb{R} $ & -- & 
		INVALID\_UX, INVALID\_UY, INVALID\_UZ, INVALID\_M \\
		.m & & $\mathbb{R}$ & -- \\
		direction & & $ \mathbb{R},\mathbb{R},\mathbb{R}$  & -- 
		\\	
		\hline
	\end{tabular}
\end{center}

\wss{You might think about direction outputting a vector.}

\subsection{Semantics}
\subsubsection{State Variables}
start := Point3D \\
ux := $\mathbb{R}$ \\
uy := $\mathbb{R}$ \\
uz := $\mathbb{R}$ \\
m := $\mathbb{R}$ \\ 

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\begin{itemize}
	\item Vectors can be created infinitely; we will only set them once during 
	initialization.			
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent Vector(p:Point3D, q:Point3D):
\begin{itemize}
	\item transition: start:= p\\
	ux:= (q.x - p.x)/m \\
	uy:= (q.y - p.y)/m \\
	uz:= (q.z - p.z)/m \\
	m := start.distance\_abs(q)\\
	\item exception: exc:= \{ p == q $\implies$ SAME\_POINTS\}
\end{itemize}

\wss{You haven't actually defined what it means for two vectors to be equal.
  You might want to add an access program for this.}

\noindent Vector($Ix: \mathbb{Z}, Iy: \mathbb{Z}, Iz: \mathbb{Z}, Im: 
\mathbb{R} 
$):
\begin{itemize}
	\item transition: ux, uy, uz, m := Ix, Iy, Iz, Im
	\item exception: exc := $(ux < -1 || ux > 1) \implies $INVALID\_UX \\
	$ | (ux < -1 || ux > 1) \implies$  INVALID\_UY \\ $| $(ux $< -1 ||$ ux $> 
	1$) $\implies $ INVALID\_UZ \\ $| (m < 0) \implies$ INVALID\_M \wss{The
          vector 0.9, 0.9, 0.9 satisfies your rules, but the magnitude is
          greater than 1.  You could just look at the distance from the origin
          to the end of the proposed unit vector.  If it is close enough to 1
          you could say that the unit vector is valid.}
\end{itemize}

\noindent .m():
\begin{itemize}
	\item output: $self.m$
	\item exception: N/A
\end{itemize}

\noindent direction():
\begin{itemize}
	\item output: $self.ux, self.uy, self.uz$
	\item exception: N/A
\end{itemize}

\noindent .start():
\begin{itemize}
	\item output: $self.start$
	\item exception: N/A
\end{itemize}


\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Light Type} \ref{MG-mTypes} \\
The Light Type module is an abstract data type which captures information 
related to the different types of light sources.

\subsection{Template Module}
LightType

\subsection{Uses}
N/A

\subsection{Syntax}
\subsubsection{Exported Types}
LightType = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{7cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		LightType & \{ambient,point,spotlight,directional\} & LightType & -- \\
		.name & & LightType & -- \\
		.i & LightType & $\mathbb{R} \times \mathbb{R} \to 
		\mathbb{R}$ & -- \\
		\hline
	\end{tabular}
\end{center}

\wss{I suggest that somewhere you export the type
  \{ambient,point,spotlight,directional\}  and give it a convenient name.}

\subsection{Semantics}
\subsubsection{State Variables}
name := \{ ambient, point, spotlight, directional \} \\
i := Function that describes how the light intensity changes as a function of 
distance. Every type of light has an associated function - so this should 
really be a set of functions.\\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent LightType(inName):
\begin{itemize}
	\item transition: self.name := inName \\
					  self.i := (name == ambient $\implies \lambda d, i_{0} \to 
					  i_{0}$ \\
					  $|$  name == directional $\implies \lambda d, i_{0} \to 
					  \frac{1}{d^2}i_{0}$ \\
					  $|$ name == point $\implies \lambda d, i_{0} \to 
					  i_{0}$\\
					  $|$ name == spotlight $\implies$)
                                          \wss{H\&S do not use $==$ for
                                            equality; they use $=$}
	\item output: self
	\item exception: exc:= \{inName $\notin$ {ambient, spotlight, point, 
	directional} $\implies$ INVALID\_LIGHT\_TYPE \}
\end{itemize}

\noindent .name():
\begin{itemize}
	\item output: $self.name$
	\item exception: N/A
\end{itemize}

\noindent .i():
\begin{itemize}
	\item output: $self.i$
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Polygon} \ref{MG-mPolygon} \\
The Polygon module is an abstract data type captures the structure of polygons 
used in polygon meshes.

\subsection{Template Module}
Polygon

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
Polygon = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{7cm} p{5cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Polygon & \{triangle, quad\}, (Point3D, Vector)$^n$ \wss{What
                          does $n$ mean here?} & -- & -- \\
		.shape & -- & \{triangle, quad\} & -- \\
		.bounds & -- & Set of (Point3D, Vector) & -- \\
		.s\_norm & -- & Vector & -- \\
		getEdges & Point3D & Set of Vectors & -- \\
		getPoints & & Set of Point3D & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
shape := \{triangle, quad\} \wss{As mentioned elsewhere, giving sets like this a
  name will make your document easier to read and write.}\\
bounds := Set of (Point3D, Vector) tuples \wss{Please use the H\&S notation.}\\
s\_norm := Vector \wss{You could calculate this as needed, rather than have it
  as a state variable.}\\

\wss{A polygon can be represented by a sequence of points.  I'm not sure why you need
  vectors in the state variables.  You could calculate a vector between two
  points if you need it, but it seems redundant to keep state information on
  both.  It is an extra headache to make sure that your points and vectors are
  consistent.  Alternatively, you could store a set of vectors.  The way you
  have defined vectors to contain a starting point, the vectors alone contain
  all of the information you need.}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent Polygon($t:\{triangle, quad\}, (p:Point3D, v:Vector)^n$):
\begin{itemize}
	\item transition:= $shape := t;$ \\
	$bounds := \cup (p,v)$ \wss{what sets is this a union of?  You cannot
          have a union of sets of different types.  I think you might need a
          different notation for what you are trying to do?}\\
	s\_norm := Calculate norm as cross-product of two vectors from 1
        vertex.  \wss{Your vector ADT does not have cross product}
	\item exception: exc := \{(t $\notin$ \{triangle, quad\} $\implies$ 
	INVALID\_SHAPE) \\ $|$ (t:\{triangle, quad\},b: Set of (Point3D, Vector)$|$ 
	t == triangle, sizeOfBounds $<$ 6 $\implies$ TOO\_FEW\_POINTS) \\ $|$ 
	(t:\{triangle, quad\},b: Set of (Point3D, Vector) $|$ t == triangle, 
	sizeOfBounds $>$ 6 $\implies$ TOO\_MANY\_POINTS) \\ $|$ 
	(t:\{triangle, quad\},b: Set of (Point3D, Vector) $|$ t == quad, 
	sizeOfBounds $>$ 8 $\implies$ TOO\_MANY\_POINTS) \\ $|$ 
	(t:\{triangle, quad\},b: Set of (Point3D, Vector) $|$ t == quad, 
	sizeOfBounds $<$ 8 $\implies$ TOO\_FEW\_POINTS)  \}\\
\end{itemize}

\noindent .shape():
\begin{itemize}
	\item output:= self.shape
	\item exception: N/A
\end{itemize}

\noindent .bounds():
\begin{itemize}
	\item output:= self.bounds
	\item exception: N/A
\end{itemize}

\noindent .s\_norm():
\begin{itemize}
	\item output:= self.s\_norm
	\item exception: N/A
\end{itemize}

\noindent getEdges(p:Point3D):\\
This method retrieves all the edges that are connected to the vertex 
represented by Point3D p. Individual polygons should have a maximum of two 
edges per vertex based on the polygon assumptions.\\
\begin{itemize}
	\item output:= Set of Vectors := $\forall b : (Point3D,Vector) | (b \in 
	self.bounds \wedge b[0] == p) \implies \cup b[1] $
	\item exception: N/A
\end{itemize}

\noindent getPoints():\\
This method retrieves the set of points in the polygon.\\
\begin{itemize}
	\item output: Set of Point3D := $b: (Point3D, Vector)| \forall b \in 
	self.bounds  \cup b.[0]$
	\item exception: N/A
\end{itemize}


\subsubsection{Local Functions}
sizeOfBounds $\equiv$ Number of elements in the set of (Point3D, Vector) 
tuples.\\

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

%%---------------------------------Complex Types--------------------------------
%%These are just the types that rely on the beasic types but are closer in 
%%detail to the problem we're trying to describe.

\section{MIS of Mesh} \ref{MG-mMesh} \\
The Mesh module is an abstract data type that captures the structure of polygon 
meshes as used by this program. It also provides methods to find out basic data 
about the polygon mesh.

\subsection{Template Module}
Mesh

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
Mesh = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Mesh & Set of Polygons & -- & -- \\
		.Surfaces & - & Set of Polygons & -- \\
		.Edges & - & Set of Vectors & -- \\
		.Vertices & - & Set of Point3D & -- \\
		isInMesh & Polygon & $\mathbb{B}$ & -- \\ %Check whether the given 
		%polygon is part of the mesh
		numPoly & Point3D & $\mathbb{Z^+}$ & -- \\ %Given a vertex, count how 
		%many polygons that vertex is attached to.
		intersects & Vector & Polygon & -- \\ %Given a vector (e.g. a ray) 
		%calculate the polygon that it intersects with in that mesh
		pointsOnMesh & Point3D & $\mathbb{B}$ & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
Vertices : Set of Point3D\\
Edges : Set of Vectors\\
Surfaces : Set of Polygons \wss{Why can't your mesh just be a set of polygons?
  The polygons already contain points and vectors.}\\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent Mesh($P:Set of Polygons$):
\begin{itemize}
	\item transition: Surfaces := P
	Vertices := $(p:Polygon | \forall p \in P \to \cup p.getPoints)$\\
	(Vertices pulls its values from the bounds of the polygons in P)\\
	Edges := $(p:Polygon, v:Point3D | \forall p \in P \forall v \in p.getPoints 
	\cup (p.getEdges(v)))$\\
	(Edges pulls its values from the bounds of the polygons in P)\\
	\item exception: exc := \{ P == $\emptyset \implies$ INVALID\_MESH\\ $| 
	(p,q:Polygon| \forall p, q \in P, p \neq q \land p.shape \neq q.shape 
	\implies$ POLYGON\_SHAPES\_MISMATCH)\\ $| (p,q:Polygon, 
	p_{1},q_{1}:Point3D| 
	\forall p \in P, \exists q \in P$ such that $\exists p_{1} \in 
	p.getPoints() 
	\land \exists q_{1} \in q.getPoints()$ such that $p_{1} \neq q_{1} 
	\implies$ 
	INVALID\_POLYS)\}
	
\end{itemize}

\noindent .Surfaces():
\begin{itemize}
	\item output := self.Surfaces
	\item exception: N/A
\end{itemize}

\noindent .Vertices():
\begin{itemize}
	\item output := self.Vertices
	\item exception: N/A
\end{itemize}

\noindent .Edges():
\begin{itemize}
	\item output := self.Edges
	\item exception: N/A
\end{itemize}

\noindent isInMesh($p:Polygon$):
\begin{itemize}
	\item output := $(q:Polygon|\exists q \in self.Surfaces where q == p)$
	\item exception: N/A
\end{itemize}

\noindent numPoly($p:Point3D$):
\begin{itemize}
	\item output:=  counter := $p \in$ self.Vertices $\implies (s:Polygon| 
	\forall s \in$ self.Surfaces) if $p \in s.bounds$ then $counter++$
	\item exception: exc := $\{p \notin self.Vertices \implies$ 
	ERR\_POINT\_NOT\_IN\_MESH\}
\end{itemize}

\noindent intersects($r:Vector$):
\begin{itemize}
	\item output := calculate whether the given vector intersects with any 
	polygon on the mesh, and return the first polygon it intersects with.
	\item exception: exc :=
\end{itemize}

\noindent pointsOnMesh(p: Point3D):
\begin{itemize}
	\item output := return true if p is a point on a polygon in the mesh.
	\item exception: exc :=
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of LightSources} \ref{MG-mLights} \\
The Light Source module is an Abstract Data Type that defines the structure and 
behaviours of light sources in the scene.
\subsection{Template Module}
LightSource

\subsection{Uses}
\wss{You want to put the modules here that define the types you will be using,
  like Point3D, Colour, etc.}
\subsection{Syntax}
\subsubsection{Exported Types}
LightSource = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{7cm} p{2cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		LightSource & Point3D, Colour, LightType, $\mathbb{R}$, Set of Vectors 
		& 
		LightSource & \\
		.origin & & Point3D & \\
		.colour & & Colour & \\
		.type & & LightType & \\
		.intensity & & $\mathbb{R}$ & \\
		\hline
	\end{tabular}
\end{center}

\wss{The Set of Vectors type in the interface may give you headaches.
  Internally using sets is fine, but when it is exposed at the interface, you
  will have to still find a set type for the implementation.  A sequence of
  vectors might be easier.}

\subsection{Semantics}
\subsubsection{State Variables}
o: Point3D \\ %%Origin position of light source
c: Colour \\
t: lightType \\
$i_{0}$: $\mathbb{R}$ \\
ds: Set of Vector \\ %%Set of direction vectors 

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}

\noindent LightSource(inP: Point3d, inC: Colour, lt: LightType, ins: 
$\mathbb{R}$ inDs: Set of Vectors):
\begin{itemize}
	\item transition: o, c, t, i, ds := inP, inC, lt, ins, inDs
	\item exception: N/A
\end{itemize}

\noindent .origin():
\begin{itemize}
	\item output:= self.o
	\item exception: N/A
\end{itemize}

\noindent .colour():
\begin{itemize}
	\item output:= self.c
	\item exception: N/A
\end{itemize}

\noindent .type():
\begin{itemize}
	\item output:= self.t
	\item exception: N/A
\end{itemize}

\noindent .intensity():
\begin{itemize}
	\item output: self.i
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Observer} \ref{MG-mObsv} \\
The Observer Module is an Abstract Data Type which captures information related 
to the camera in a scene. While there's no behaviour and this type of 
information could be represented as an Abstract Object since there's only one 
at any time in the scene, I'm attempting to future proof the design by keeping 
it an Abstract Data Type.

\subsection{Template Module}
Observer

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
Observer = ?
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		Observer & Point3D, Vector & Observer & -- \\
		\hline
	\end{tabular}
\end{center}

\wss{If you only have a constructor, how do any other modules use the state
  information?  If this module really is just data, you might save yourself some
  work by defining it as an exported type.}

\subsection{Semantics}
\subsubsection{State Variables}
p : Point3D\\
d : Vector\\

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
There is only one observer in the scene at any time. This might change in 
future versions of this software, but as it exists we're only looking at the 
objects from one view.

\subsubsection{Access Routine Semantics}
\noindent Observer(inP: Point3D, inD : Vector):
\begin{itemize}
	\item transition: p := inP \\
	d := inD
	\item output := self
	\item exception: exc := \wss{If there are no exceptions, you should say
            ``none'' explicitly.}
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of NormalMap} \ref{MG-mNormals} \\
The NormalMap module is an Abstract Data Type which captures information about 
the normal maps of an object mesh. This information is necessary for 
calculating reflections and is easier to calculate once and store instead of 
calculating on the fly.

\subsection{Template Module}
NormalMap

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
NormalMap = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		NormalMap & Set of (Point3D, Vector) & NormalMap & -- \\
		\hline
	\end{tabular}
\end{center}

\wss{Again, you only have a constructor in the interface.  You likely want some
  getters at least.  Having Set as the type in your interface may cause you some
headaches.  If you really want Set, you should probably define an Generic ADT
for Set.}

\subsection{Semantics}
\subsubsection{State Variables}
NormalMap = Set of (Point3D, Vector)

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}


\subsubsection{Access Routine Semantics}
\noindent NormalMap(ns : (Point3D,Vector)):
\begin{itemize}
	\item transition: p := inP \\
	d := inD
	\item output := self
	\item exception: exc :=
\end{itemize}

\noindent getNormal(p:Point3D):
\begin{itemize}
	\item output := 
	\item exception: exc :=
\end{itemize}


\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Object} \ref{MG-mObjects} \\
The Object module is an abstract data type that captures the structure of 
objects in the scenes defined by this program.

\subsection{Template Module}
Object

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Types}
Object = ?

\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{4cm} p{2cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		
		\multirow{10}{*}{Object} & Mesh, & Object & \\
		& Point3D, & & \\
		& $\mathbb{R}$, & & \\  
		& Colour, & & \\
		& Colour, & & \\
		& $\mathbb{Z},$ & & \\
		& $\mathbb{Z},$ & & \\
		& $\mathbb{Z},$ & & \\
		& $\mathbb{N},$ & & \\
		& \{FLAT, GOURAUD, PHONG\} & & \\		
		%%Getters
		.Mesh & - & Mesh & - \\
		.Position & - & Point3D & - \\
		.Size &- & $\mathbb{Z}$ & \\
		.BaseColour &- & Colour & \\
		.SpecColour &- & Colour & \\
		.kd &- & $\mathbb{R}$ & \\
		.ka &- & $\mathbb{R}$& \\
		.ks &- & $\mathbb{R}$ & \\
		.alpha &- & $\mathbb{N}$ & \\
		.nmap &- & NormalMap& \\ 
		%%Setters
		SetObj\_Position & Point3D & - & \\
		SetObj\_Size & $\mathbb{R}$ & - & \\
		SetObj\_BaseColour & Colour &- & \\
		SetObj\_SpecColour & Colour &- & \\
		SetObj\_kd & $\mathbb{R}$ &- & IV\_OUT\_OF\_BOUNDS\\
		SetObj\_ka & $\mathbb{R}$&- & IV\_OUT\_OF\_BOUNDS\\
		SetObj\_ks & $\mathbb{R}$ &- & IV\_OUT\_OF\_BOUNDS\\
		SetObj\_alpha & $\mathbb{Z}^+$ &- & IV\_OUT\_OF\_BOUNDS\\
		SetObj\_NormalMap & $nMap$ &- &- \\
		%%
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
baseColour : Colour \\
specColour : Colour \\
centrePoint : Point3D \\
mesh : Mesh \\ 
ka : $\mathbb{R}$ \\
ks : $\mathbb{R}$ \\
kd : $\mathbb{R}$ \\
alpha : $\mathbb{Z}^+$ \\
nMap : NormalMap \\
size : $\mathbb{R}$\\
shade : \{FLAT, GOURAUD, PHONG\}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent Object(inM: Mesh, inP : Point3D, inSize : 
$\mathbb{R}$,  inBase : Colour, inSpec : Colour, inD : $\mathbb{Z}$, inA : 
$\mathbb{R}$, inS : $\mathbb{R}$, inAlpha : $\mathbb{N}$, inShade : \{FLAT, 
GOURAUD, PHONG\}):
\begin{itemize}
	\item transition: mesh, baseColour, specColour, centrePoint, ka, kd, ks, 
	alpha, size := inM, inBase, inSpec, inP, inA, inD, inS, inAlpha, inSize\\
	nMap := Shader.findNormals(shade, self)
	\item exception: N/A
\end{itemize}

\noindent .Mesh():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.m
	\item exception: N/A
\end{itemize}

\noindent .Position():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.centrePoint
	\item exception: N/A
\end{itemize}

\noindent .Size():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.size
	\item exception: N/A
\end{itemize}

\noindent .BaseColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.baseColour
	\item exception: N/A
\end{itemize}

\noindent .SpecColour():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.specColour
	\item exception: N/A
\end{itemize}

\noindent .kd():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.kd
	\item exception: N/A
\end{itemize}

\noindent .ka():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.ka
	\item exception: N/A
\end{itemize}

\noindent .ks():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.ks
	\item exception: N/A
\end{itemize}

\noindent .alpha():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: self.alpha
	\item exception: N/A
\end{itemize}

\noindent .NormalMap():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output:= self.nMap
	\item exception: N/A
\end{itemize}
%%Setters
\noindent SetObj\_Position(p: Point3D):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: centrePoint := p
	\item exception: N/A
\end{itemize}

\noindent SetObj\_Size(s : $\mathbb{R}$):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: size := s
	\item exception: N/A
\end{itemize}

\noindent SetObj\_BaseColour(c : Colour):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: baseColour := c
	\item exception: exc := {\\
					c.r $>$ 255 $\implies$ IV\_OUT\_OF\_BOUNDS\\
					$|$ \\
					c.g > 255 $\implies$ IV\_OUT\_OF\_BOUNDS \\
					$|$ \\
					c.b > 255 $\implies$ IV\_OUT\_OF\_BOUNDS\\
					$|$ \\
					c.r < 1 $\implies$ IV\_OUT\_OF\_BOUNDS\\
					$|$ \\
					c.g < 1 $\implies$ IV\_OUT\_OF\_BOUNDS \\
					$|$ \\
					c.b < 1 $\implies$ IV\_OUT\_OF\_BOUNDS}	\\	
\end{itemize} \wss{I fixed one of your > to be $>$, you will have to fix the
  other ones too.}

\noindent SetObj\_SpecColour(c : Colour):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: specColour := c
	\item exception: exc := {\\
					c.r > 255 $\implies$ IV\_OUT\_OF\_BOUNDS\\
					$|$ \\
					c.g > 255 $\implies$ IV\_OUT\_OF\_BOUNDS \\
					$|$ \\
					c.b > 255 $\implies$ IV\_OUT\_OF\_BOUNDS	\\
					$|$ \\
					c.r < 1 $\implies$ IV\_OUT\_OF\_BOUNDS\\
					$|$ \\
					c.g < 1 $\implies$ IV\_OUT\_OF\_BOUNDS \\
					$|$ \\
					c.b < 1 $\implies$ IV\_OUT\_OF\_BOUNDS}	\\	 
\end{itemize}

\noindent SetObj\_kd(d: $\mathbb{R}$):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: kd := d
	\item exception: exc := {\\
		d > 1 $\implies$ COEFFICIENT\_TOO\_HIGH\\
		d < 0.5 $\implies$ COEFFICIENT\_TOO\_LOW\\}
\end{itemize}

\noindent SetObj\_ka(a: $\mathbb{R}$):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: ka := a
	\item exception: exc := {\\
		a > 1 $\implies$ COEFFICIENT\_TOO\_HIGH\\
		a < 0 $\implies$ COEFFICIENT\_TOO\_LOW\\}
\end{itemize}

\noindent SetObj\_ks(s: $\mathbb{R}$):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: ks := s
	\item exception: exc := {\\
		s > 1 $\implies$ COEFFICIENT\_TOO\_HIGH\\
		s < 0 $\implies$ COEFFICIENT\_TOO\_LOW\\}
\end{itemize}

\noindent SetObj\_alpha(al: $\mathbb{N}$):
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item transition: alpha := al
	\item exception: exc := {\\
		a < 0 $\implies$ COEFFICIENT\_TOO\_LOW\\}
\end{itemize}

\noindent SetObj\_NormalMap():
\begin{itemize}
	%\item transition: \wss{if appropriate} 
	\item output: A normal map of the object. This is a list of normals based 
	on shader calculations, and a string literal that describes the type of 
	normals (vertex, surface, pixel).
	\item exception: N/A
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Scene Module} \ref{MG-mScene} \\
The Scene Module is an abstract object module that contains the structure for 
the overall scene. It maintains information about the entities in the scene 
(object, light source, observer) regarding their distances between each other. 
It constrains the positions, sizes, and directions of entities based on the 
specified size of the scene.
%\wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
Scene

\subsection{Uses}
Input, Output

\subsection{Syntax}
\subsubsection{Exported Constants}
SCENE\_MAX\_H : $\mathbb{R}^+$\\
SCENE\_MIN\_H : $\mathbb{R}^+$\\
SCENE\_MAX\_W : $\mathbb{R}^+$\\
SCENE\_MIN\_W : $\mathbb{R}^+$\\
SCENE\_MAX\_D : $\mathbb{R}^+$\\
SCENE\_MIN\_D : $\mathbb{R}^+$\\
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{7}{4cm}{initScene} & $\mathbb{R}^+$ & Scene & 
		HEIGHT\_TOO\_SMALL, 
		HEIGHT\_TOO\_LARGE\\
		& $\mathbb{R}^+$ & & WIDTH\_TOO\_SMALL, 
		WIDTH\_TOO\_LARGE\\		
		& $\mathbb{R}^+$ & & DEPTH\_TOO\_SMALL, 
		DEPTH\_TOO\_LARGE\\				 
		& Object & & INVALID\_OBJECT\_POSITION\\				 
		& LightSource & & INVALID\_LIGHT\_POSITION\\
		& Observer & & INVALID\_OBSV\_POSITION\\
		& \{DIFFUSE, HALF-LAMBERT, PHONG, BLINN-PHONG\} & & \\
		compile & -- & OutputObject & -- \\
		\hline
		changeObj & Object & - & \\
		changeLightSource & LightSource & - & \\
		changeLightModel & LightingModel & - & \\
		changeShader & ShadingModel & - & \\
		changeRoomSize & $\mathbb{R},\mathbb{R},\mathbb{R}$ & - & \\
		
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
height : $\mathbb{R}$\\
width : $\mathbb{R}$\\
depth : $\mathbb{R}$\\
obs : Observer \\
ls : LightSource \\
os : Object  \wss{Your scenes have just one object?  That is fine, but I want to
make sure that is your intention.}\\ 
lightModel : \{DIFFUSE, HALF-LAMBERT, PHONG, BLINN-PHONG\}

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}
\noindent initScene($h: \mathbb{R}, w: \mathbb{R}, d: \mathbb{R}$, o: Object, 
l: LightSource, ob: Observer, lm: \{DIFFUSE, HALF-LAMBERT, PHONG, 
BLINN-PHONG\}):
\begin{itemize}
	\item transition: height, width, depth, obs, ls, os, lightModel := h, w, d, 
	ob, l, o, lm
	\item output := self
	\item exception: exc := \{(h $\le$ SCENE\_MIN\_H $\implies$ 
	HEIGHT\_TOO\_SMALL) \\
	$|$ (h $\ge$ SCENE\_MAX\_H $\implies$ HEIGHT\_TOO\_LARGE) \\
	$|$ (w $\le$ SCENE\_MIN\_W $\implies$ WIDTH\_TOO\_SMALL) \\
	$|$ (w $\ge$ SCENE\_MAX\_W $\implies$ WIDTH\_TOO\_LARGE) \\
	$|$ (d $\le$ SCENE\_MIN\_D $\implies$ DEPTH\_TOO\_SMALL) \\
	$|$ (d $\ge$ SCENE\_MAX\_D $\implies$ DEPTH\_TOO\_LARGE) \\
	$|$ ($\not$ (objectInScene(o)) $\implies$	INVALID\_OBJECT\_POSITION \\
	$|$ ($\not$ (lightInScene(l)) $\implies$	INVALID\_LIGHT\_POSITION \\	
	$|$ ($\not$ (obsvInScene(obs)) $\implies$	INVALID\_OBSV\_POSITION \\		
	\}
\end{itemize}

\subsubsection{Local Functions}
objectInScene(o : Object) $\equiv$ (SCENE\_MIN\_H < o.position.y < 
SCENE\_MAX\_H) 
$\land$ (SCENE\_MIN\_W < o.position.x < SCENE\_MAX\_W) $\land$ 
(SCENE\_MIN\_D < o.position.z < SCENE\_MAX\_D) \\
~\newline
lightInScene(l : LightSource) $\equiv$ (SCENE\_MIN\_H < l.position.y < 
SCENE\_MAX\_H) 
$\land$ (SCENE\_MIN\_W < l.position.x < SCENE\_MAX\_W) $\land$ 
(SCENE\_MIN\_D < l.position.z < SCENE\_MAX\_D)\\
~\newline
obsvInScene(o : Observer) $\equiv$ (SCENE\_MIN\_H < o.position.y < 
SCENE\_MAX\_H) 
$\land$ (SCENE\_MIN\_W < o.position.x < SCENE\_MAX\_W) $\land$ 
(SCENE\_MIN\_D < o.position.z < SCENE\_MAX\_D) \\

%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

%%---------------------------------Libraries------------------------------------
\section{MIS of VecMath} \ref{MG-mVecMath} \\
The Vector Math module is a library of services that can be used with Vectors. 
All functions here take in 2 Vectors and output either a Vector or a scalar 
value. \wss{This is fine.  Earlier I pointed out that your Vector ADT did not
  have a cross product.  I see now that you have a library for these
  calculations.  You should use the Uses clause as it was intended so that the
  reader can find the required information for one module by reading that
  module's spec, and the spec for the Uses modules.}

\subsection{Module}
VecMath

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}
N/A
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		add & Vector, Vector & Vector & -- \\
		sclMult & Vector, $\mathbb{R}$ & Vector & -- \\ 
		dot & Vector, Vector & $\mathbb{R}$ & -- \\
		cross & Vector, Vector & Vector & -- \\
		angleBetween & Vector, Vector & rad & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}

\subsubsection{Environment Variables}
N/A
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent add($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: 
	Vector((v1.x+v2.x),(v1.y+v2.y),(v1.z,v2.z), \\
	$\sqrt{(v1.x+v2.x)^2+(v1.y+v2.y)^2+(v1.z,v2.z)^2}$)
	\item exception: exc := \\
\end{itemize} \wss{Your add will have a problem because the three components are
  unlikely to form a unit vector.}

\noindent sclMult($v1:Vector, r:\mathbb{R}$):
\begin{itemize}
	\item output: 
	ux := $r \times v1.x$ \\
	uy := $r \times v1.y$ \\
	uz := $r \times v1.z$ \\	
	\item exception: \\
\end{itemize} \wss{You do not have access to the state variables here.  Also,
  these will not be unit vectors, except in very rare cases.  Your output should
call the Vector constructor with the right parameters.  You are also missing the
start point, which is something you made part of the Vector type.}


\noindent dot($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: 
	ux := $v1.x \times v2.x$ \\
	uy := $v1.y \times v2.y$ \\
	uz := $v1.z \times v2.z$ \\
	\item exception: \\
\end{itemize} \wss{This isn't the definition of dot product.  Dot product is a
  scalar (real) value.}

\noindent cross($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: 
	ux := $(v1.y \times v2.z) - (v1.z \times v2.y)$  \\
	uy := $(v1.z \times v2.x) - (v1.x \times v2.z)$  \\
	uz := $(v1.x \times v2.y) - (v1.y \times v2.x)$  \\
	\item exception: \\
\end{itemize} \wss{You need to call your Vector constructor with the appropriate arguments.}

\noindent angleBetween($v1:Vector, v2:Vector$):
\begin{itemize}
	\item output: $\cos^{-1}(\frac{dot(v1, v2)}{v1.m \times v2.m})$
	\item exception: \\
\end{itemize}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\section{MIS of Shader} \ref{MG-mShader} \\
The Shader module is a library that calculates the normal map of an object 
given a shading model and said object. It handles the different types of 
shadings that are possible and handles the interpolation of normals between 
points.

\subsection{Module}
Shader

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}
N/A
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		interpolate & (Point3D, Vector), (Point3D, Vector), Point3D & Vector & 
		-- \\
		findNormals & ShadingModel, Object & NormalMap & -- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent interpolate(s: (Point3D, Vector), e: (Point3D, Vector), p: Point3D):
\begin{itemize}
	\item output:= Linear interpolation of normal values between starting 
	vertex (s[0]) and ending vertex (s[1]).\\
	\item exception: \\
\end{itemize} \wss{It would be nice to see the formula for the interpolation.
  It is a simple formula, but I have no idea how it relates to the arguments
  that are provided.  More information is needed to make it clear.  What is
  being interpolated?  Is it the vector at the two points?  Is the interpolation
  component wise?}

\noindent findNormals(s:ShadingModel, o:Object):
\begin{itemize}
	\item output: ns : NormalMap :=
	(s == FLAT $\implies$ all points on the mesh have a normal equal to their 
	polygon's surface normal.\\
	\textit{$\forall$ q:Point3D, $\exists$ p:Polygon $|$ q $\in$ p.getPoints() 
	$\land$ p $\in$ o.Mesh.Surfaces() $\to$ (q,p.s\_norm)\\} 
	\\
	$|$ s == GOURAUD $\implies$ all vertices on the mesh have a normal equal to 
	the average of the surface normals of the polygons they are a part of. The 
	normals of the points in between the vertices are not calculated.\\
	\textit{$\forall$ v : Point3D $|$ v $\in$ o.Mesh.Vertices() $\to \forall$ p 
	: Polygon $|$ v $\in$ p.getPoints() \\
	\textit{begin:}
	\begin{itemize}
		\item[] sum:= +(p.s\_norm) --- \textit{Add the surface norms 
			together}.
		\item[] counter++ --- \textit{Count how many polygons are a part of 
			this}.
	\end{itemize} 
	\textit{end} $ to$ (v, sum/counter)}\\ \wss{Since you are not using the
          notation we used in class, I do not know how to read this.  Does the
          arrow mean implication?  Is this a boolean expression?  It is great
        that you are working on the math, but this might be a case where a
        pseudo code algorithm is more practical.}
	%%Gouraud shading takes sets the normal at the vertex to be the average of 
	%%the surface normals for all the polygons that vertex is a part of. It 
	%%then calculates the colour at the vertices and interpolates the colours 
	%%between vertices.
	\\
	$|$ s == PHONG $\implies$ all vertices on the mesh have a normal equal to 
	the average of the surface normals of the polygons they are a part of. The 
	normals of the points in between the vertices of a polygon are calculated 
	by interpolating their values between the vertices.\\
	\textit{begin:
	\begin{enumerate}
		\item ns := ns $\cup$ ($\forall$ v : Point3D $|$ v $\in$ 
		o.Mesh.Vertices() 
		$\to$ $\forall$ p : Polygon $|$ v $\in$ p.getPoints() \\
		\textit{begin:}
		\begin{itemize}
			\item[] sum:= +(p.s\_norm) --- \textit{Add the surface norms 
				together}.
			\item[] counter++ --- \textit{Count how many polygons are a part of 
				this}.
		\end{itemize}
		\textit{end} $\to$ (v, sum/counter))
		\item ns := ns $\cup$ ($\forall$ start, end, p : Point3D $|$ start, 
		end, p $\in$ o.Mesh.pointsOnMesh() $\land$ start, end $\in$ 
		o.Mesh.Vertices() $\land$ p $\notin$ o.Mesh.Vertices() $\to$ (p,
		interpolate((start,), (end, ), p)))
	\end{enumerate}
	end\\}
	%%Phong shading sets the vertex normals to be the average of the surface 
	%%normals for all the polygons that vertex is a part of.
	)
	
	\item exception: -- \\
\end{itemize}

\section{MIS of LightingModel} \ref{MG-mLightModel} \\
The LightingModel module is a library that provides the intensity functions for 
final scene colouring calculations.
\subsection{Module}
LightModel

\subsection{Uses}

\subsection{Syntax}
\subsubsection{Exported Constants}
models := \{DIFFUSE, HALF-LAMBERT, PHONG, BLINN-PHONG\}
\subsubsection{Exported Access Programs}
\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{2cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		intensity & models & LightSource, Object $\to \lambda$ I & \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}
\subsubsection{State Variables}
N/A
\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}
\noindent intensity(l: LightSource, o: Object):
\begin{itemize}
	\item output:= \{ model == DIFFUSE $\implies \lambda$ l, o $\to$ a function 
	where ((l.direction() $\bullet$ 
	o.intersects(l.direction()))$(I_{L_{i}p}$)$\cdot$(l.colour())\\
	$|$ model == HALF-LAMBERT $\implies \lambda$ l, o $\to$ a function 
	where  $[(obj.intersects(l.direction()) \bullet l.direction())\cdot 
	obj.k_{d} + (1-obj.k_{d})]^2$\\
	$|$ model == PHONG $\implies \lambda$ l, o $\to i(p,p_{0}) \cdot k_{a} + 
	k_{d}\cdot i(p,p_{0}) \cdot 
	\max(0,(L_{i}\bullet N)) + k_{s}\cdot i(p,p_{0}) \cdot \max(0, 
	({L_{r}}\bullet V))^\alpha$\\
	$|$ model == BLINN-PHONG $\implies \lambda$ l, o $\to$ a function where 
	$i(p,p_{0}) \cdot$ o.ka + o.kd$\cdot \max(0, (N \bullet 
	l.direction))\cdot i(p,p_{0}) +$ o.ks $\cdot \max(0, (N \bullet 
	H))^{o.alpha} \cdot	i(p,p_{0}$
	\}
\end{itemize} \wss{I think I can see what you are getting at, but the math
  notation needs some work.  In particular, I don't know what the big dots
  mean.  Is this multiplication?  Is it a dot product?  Do the types all make
  sense for whatever operation the big dot implies?}

\subsubsection{Local Functions}
N/A
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

%\wss{Extra information if required}

\end{document}